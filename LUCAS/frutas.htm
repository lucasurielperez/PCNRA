<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Frutas con Rebote y Rotación</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #87CEEB;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #333;
            background-color: #F5F5F5;
            touch-action: none;
        }
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #333;
            font-size: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Puntaje: 0</div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');

        canvas.width = Math.min(window.innerWidth * 0.9, 400);
        canvas.height = Math.min(window.innerHeight * 0.9, 600) - 50;

        const GRAVITY = 0.975; // 50% más fuerte que 0.65
        const BOUNCE_WALL = 0.95;  // Aumentado de 0.9 a 0.95
        const BOUNCE_FLOOR = 0.95; // Aumentado de 0.9 a 0.95
        const BOUNCE_FRUIT = 0.85; // Aumentado de 0.8 a 0.85
        const FRICTION = 0.85;
        const ROTATION_FRICTION = 0.98;
        const MAX_ANGULAR_VELOCITY = 2 * Math.PI / 60;

        let score = 0;

        class Fruit {
            constructor(x, y, type, scale = 1) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = [10, 15, 24, 33, 42, 51, 60][type];
                this.vx = 0;
                this.vy = 0;
                this.mass = this.radius;
                this.scale = scale;
                this.shrinkSpeed = 0;
                this.growSpeed = 0;
                this.angle = 0;
                this.angularVelocity = 0;
            }

            // ... (el método draw() permanece igual)

            update() {
                this.vy += GRAVITY;
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= FRICTION;
                this.vy *= FRICTION;

                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 0.5) {
                    this.angle += this.angularVelocity;
                    this.angularVelocity = Math.max(-MAX_ANGULAR_VELOCITY, Math.min(MAX_ANGULAR_VELOCITY, this.angularVelocity));
                    this.angularVelocity *= ROTATION_FRICTION;
                } else {
                    this.angularVelocity = 0;
                }

                // Colisión con pared izquierda
                if (this.x - this.radius * this.scale < 0) {
                    this.x = this.radius * this.scale;
                    this.vx = Math.abs(this.vx) * BOUNCE_WALL;  // Forzamos rebote positivo
                    this.angularVelocity += this.vy * 0.03;
                }
                // Colisión con pared derecha
                else if (this.x + this.radius * this.scale > canvas.width) {
                    this.x = canvas.width - this.radius * this.scale;
                    this.vx = -Math.abs(this.vx) * BOUNCE_WALL;  // Forzamos rebote negativo
                    this.angularVelocity -= this.vy * 0.03;
                }
                // Colisión con el suelo
                if (this.y + this.radius * this.scale > canvas.height) {
                    this.y = canvas.height - this.radius * this.scale;
                    this.vy = -Math.abs(this.vy) * BOUNCE_FLOOR;  // Forzamos rebote hacia arriba
                    this.angularVelocity += this.vx * 0.03;
                    if (Math.abs(this.vy) < 1) this.vy = 0;  // Aumentamos el umbral
                }

                if (this.shrinkSpeed > 0) {
                    this.scale -= this.shrinkSpeed;
                    if (this.scale <= 0) this.scale = 0;
                }
                if (this.growSpeed > 0) {
                    this.scale += this.growSpeed;
                    if (this.scale >= 1) this.scale = 1;
                }
            }
        }

        // ... (el resto del código permanece igual hasta checkCollisions())

        function checkCollisions() {
            for (let i = 0; i < fruits.length; i++) {
                for (let j = i + 1; j < fruits.length; j++) {
                    let f1 = fruits[i];
                    let f2 = fruits[j];
                    let dx = f2.x - f1.x;
                    let dy = f2.y - f1.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < (f1.radius * f1.scale + f2.radius * f2.scale) && f1.scale > 0 && f2.scale > 0) {
                        if (f1.type === f2.type) {
                            // ... (código de fusión igual)
                        } else {
                            let angle = Math.atan2(dy, dx);
                            let sin = Math.sin(angle);
                            let cos = Math.cos(angle);

                            let vx1 = f1.vx * cos + f1.vy * sin;
                            let vy1 = f1.vy * cos - f1.vx * sin;
                            let vx2 = f2.vx * cos + f2.vy * sin;
                            let vy2 = f2.vy * cos - f2.vx * sin;

                            let finalVx1 = ((f1.mass - f2.mass) * vx1 + 2 * f2.mass * vx2) / (f1.mass + f2.mass);
                            let finalVx2 = ((f2.mass - f1.mass) * vx2 + 2 * f1.mass * vx1) / (f1.mass + f2.mass);

                            let relativeVelocityX = vx2 - vx1;
                            let relativeVelocityY = vy2 - vy1;
                            let impulse = (finalVx1 - vx1) * f1.mass;
                            let angularImpulse = (relativeVelocityX * dy - relativeVelocityY * dx) / (f1.radius + f2.radius);
                            f1.angularVelocity += angularImpulse / f1.radius * 0.03;
                            f2.angularVelocity -= angularImpulse / f2.radius * 0.03;

                            // Aseguramos que el rebote sea más pronunciado
                            f1.vx = (cos * finalVx1 - sin * vy1) * BOUNCE_FRUIT;
                            f1.vy = (sin * finalVx1 + cos * vy1) * BOUNCE_FRUIT;
                            f2.vx = (cos * finalVx2 - sin * vy2) * BOUNCE_FRUIT;
                            f2.vy = (sin * finalVx2 + cos * vy2) * BOUNCE_FRUIT;

                            let overlap = (f1.radius * f1.scale + f2.radius * f2.scale) - distance;
                            f1.x -= dx * overlap / distance / 2;
                            f1.y -= dy * overlap / distance / 2;
                            f2.x += dx * overlap / distance / 2;
                            f2.y += dy * overlap / distance / 2;

                            if (Math.abs(f1.vx) < 1) f1.vx = 0;
                            if (Math.abs(f1.vy) < 1) f1.vy = 0;
                            if (Math.abs(f2.vx) < 1) f2.vx = 0;
                            if (Math.abs(f2.vy) < 1) f2.vy = 0;
                        }
                    }
                }
            }
        }

        // ... (el resto del código permanece igual)
    </script>
</body>
</html>