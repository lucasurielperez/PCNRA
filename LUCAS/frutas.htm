function checkCollisions() {
    if (gameOver) return;
    for (let i = 0; i < fruits.length; i++) {
        for (let j = i + 1; j < fruits.length; j++) {
            let f1 = fruits[i];
            let f2 = fruits[j];
            let dx = f2.x - f1.x;
            let dy = f2.y - f1.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            let minDistance = f1.radius * f1.scale + f2.radius * f2.scale;

            if (distance < minDistance && f1.scale >= 0.9 && f2.scale >= 0.9) {
                if (f1.isFrozen && f2.isFrozen) continue;

                if (!f1.isFrozen) f1.lastPerturbedTime = Date.now();
                if (!f2.isFrozen) f2.lastPerturbedTime = Date.now();
                f1.isFrozen = false;
                f2.isFrozen = false;

                if (f1.type === f2.type && !f1.isMerging && !f2.isMerging) {
                    f1.isMerging = true;
                    f2.isMerging = true;
                    f1.shrinkSpeed = 0.1;
                    f2.shrinkSpeed = 0.1;
                    if (f1.type === 6) {
                        setTimeout(() => {
                            const index1 = fruits.indexOf(f1);
                            const index2 = fruits.indexOf(f2);
                            if (index1 !== -1 && index2 !== -1) {
                                fruits.splice(index1, 1);
                                fruits.splice(index2 > index1 ? index2 - 1 : index2, 1);
                                score++;
                                scoreDisplay.textContent = `Puntaje: ${score}`;
                                triggerConfettiExplosion(f1.x, f1.y, 40, 6);
                                setTimeout(() => triggerConfettiExplosion(f1.x, f1.y, 40, 6), 200);
                                setTimeout(() => triggerConfettiExplosion(f1.x, f1.y, 40, 6), 400);
                            }
                        }, 100);
                    } else {
                        let newType = f1.type + 1;
                        let newX = (f1.x + f2.x) / 2;
                        let newY = (f1.y + f2.y) / 2;
                        setTimeout(() => {
                            const index1 = fruits.indexOf(f1);
                            const index2 = fruits.indexOf(f2);
                            if (index1 !== -1 && index2 !== -1) {
                                fruits.splice(index1, 1);
                                fruits.splice(index2 > index1 ? index2 - 1 : index2, 1);
                                let newFruit = new Fruit(newX, newY, newType, 0);
                                newFruit.growSpeed = 0.1;
                                newFruit.angularVelocity = (Math.random() - 0.5) * 0.1; // Nueva rotación por fusión
                                fruits.push(newFruit);
                                triggerConfettiExplosion(newX, newY, 20, f1.type);
                            }
                        }, 100);
                    }
                } else if (f1.isMerging || f2.isMerging) {
                    let nx = dx / distance || 0;
                    let ny = dy / distance || 0;
                    let overlap = minDistance - distance;
                    let correction = overlap / 2;
                    if (!f1.isFrozen) {
                        f1.x -= nx * correction;
                        f1.y -= ny * correction;
                    }
                    if (!f2.isFrozen) {
                        f2.x += nx * correction;
                        f2.y += ny * correction;
                    }
                } else if (!f1.isFrozen || !f2.isFrozen) {
                    let nx = dx / distance || 0;
                    let ny = dy / distance || 0;

                    let overlap = minDistance - distance;
                    let correction = overlap / 2;
                    if (!f1.isFrozen) {
                        f1.x -= nx * correction;
                        f1.y -= ny * correction;
                    }
                    if (!f2.isFrozen) {
                        f2.x += nx * correction;
                        f2.y += ny * correction;
                    }

                    let fallingFruit = f1.vy > f2.vy ? f1 : f2;
                    let restingFruit = f1.vy > f2.vy ? f2 : f1;

                    let v1n = fallingFruit.vx * nx + fallingFruit.vy * ny;
                    let v2n = restingFruit.vx * nx + restingFruit.vy * ny;

                    let v1t = fallingFruit.vx - v1n * nx;
                    let v2t = restingFruit.vx - v2n * nx;

                    let totalMass = fallingFruit.mass + restingFruit.mass;
                    let massRatio = fallingFruit.mass / restingFruit.mass;

                    let finalV1n = ((fallingFruit.mass - restingFruit.mass) * v1n + 2 * restingFruit.mass * v2n) / totalMass;
                    let finalV2n = ((restingFruit.mass - fallingFruit.mass) * v2n + 2 * fallingFruit.mass * v1n) / totalMass;

                    const bounceFactor = 0.3 * (1 - (fallingFruit.mass + restingFruit.mass) / 128 * 0.5);
                    const energyLoss = 0.7;
                    finalV1n *= bounceFactor * energyLoss;
                    finalV2n *= bounceFactor * energyLoss;

                    // Limitar energía a la inicial
                    const maxSpeed = Math.sqrt(fallingFruit.initialEnergy);
                    finalV1n = Math.max(-maxSpeed, Math.min(maxSpeed, finalV1n));
                    finalV2n = Math.max(-maxSpeed, Math.min(maxSpeed, finalV2n));

                    // Restricción: Frutas pequeñas no elevan a las grandes
                    if (fallingFruit.mass < restingFruit.mass) {
                        finalV2n = Math.max(finalV2n, 0); // No permite elevación hacia arriba
                        finalV1n *= Math.min(1, restingFruit.mass / fallingFruit.mass * 0.5); // Reduce rebote de la pequeña
                    } else {
                        finalV2n *= Math.min(1, fallingFruit.mass / restingFruit.mass * 0.5);
                    }

                    if (!fallingFruit.isFrozen) {
                        fallingFruit.vx = v1t + finalV1n * nx;
                        fallingFruit.vy = finalV1n * ny;
                        fallingFruit.vx = Math.max(-maxSpeed, Math.min(maxSpeed, fallingFruit.vx));
                        fallingFruit.vy = Math.max(-maxSpeed, Math.min(maxSpeed, fallingFruit.vy));
                    }
                    if (!restingFruit.isFrozen) {
                        restingFruit.vx = v2t + finalV2n * nx;
                        restingFruit.vy = finalV2n * ny;
                        restingFruit.vx = Math.max(-maxSpeed, Math.min(maxSpeed, restingFruit.vx));
                        restingFruit.vy = Math.max(-maxSpeed, Math.min(maxSpeed, restingFruit.vy));
                    }

                    let relativeVelocityX = f2.vx - f1.vx;
                    let relativeVelocityY = f2.vy - f1.vy;
                    let angularImpulse = (relativeVelocityX * dy - relativeVelocityY * dx) / (f1.radius + f2.radius);
                    if (!f1.isFrozen) f1.angularVelocity = Math.min(0.01, (angularImpulse / f1.radius * 0.005) / f1.mass);
                    if (!f2.isFrozen) f2.angularVelocity = Math.min(0.01, (angularImpulse / f2.radius * 0.005) / f2.mass);

                    if (!f1.isFrozen && Math.abs(f1.vx) < 0.1) f1.vx = 0;
                    if (!f1.isFrozen && Math.abs(f1.vy) < 0.1) f1.vy = 0;
                    if (!f2.isFrozen && Math.abs(f2.vx) < 0.1) f2.vx = 0;
                    if (!f2.isFrozen && Math.abs(f2.vy) < 0.1) f2.vy = 0;
                }
            }
        }
    }
}