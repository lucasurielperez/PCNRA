<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Frutas con Rebote Realista</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #87CEEB;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #333;
            background-color: #F5F5F5;
            touch-action: none;
        }
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #333;
            font-size: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Puntaje: 0</div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');

        canvas.width = Math.min(window.innerWidth * 0.9, 400);
        canvas.height = Math.min(window.innerHeight * 0.9, 600) - 50;

        const GRAVITY = 9.81 / 60; // Gravedad terrestre ajustada a 60 FPS
        const TERMINAL_VELOCITY = 20; // Velocidad terminal
        const FRICTION = 0.98; // Fricción leve
        const MAX_ANGULAR_VELOCITY = Math.PI / 4 / 60; // Rotación máxima

        let score = 0;

        class Fruit {
            constructor(x, y, type, scale = 1) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = [10, 15, 24, 33, 42, 51, 60][type];
                this.vx = 0;
                this.vy = 0;
                this.mass = this.radius;
                this.scale = scale;
                this.shrinkSpeed = 0;
                this.growSpeed = 0;
                this.angle = 0;
                this.angularVelocity = 0;
                this.bounceCount = 0;
                this.lastImpactVelocity = { x: 0, y: 0 }; // Última velocidad antes del impacto
                this.isSettled = false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                ctx.rotate(this.angle);
                if (this.type === 0) { // Uvas
                    ctx.fillStyle = '#90EE90';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(3, -3, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.arc(0, 2, this.radius - 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 1) { // Cereza
                    ctx.fillStyle = '#FF4040';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.moveTo(0, -this.radius);
                    ctx.lineTo(5, -this.radius - 10);
                    ctx.lineTo(-5, -this.radius - 15);
                    ctx.fill();
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(5, 5, 3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.arc(0, 5, this.radius - 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 2) { // Ciruela
                    ctx.fillStyle = '#800080';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.arc(0, -this.radius + 5, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#DDA0DD';
                    ctx.beginPath();
                    ctx.arc(-5, 5, 4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(8, -8, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 3) { // Naranja
                    ctx.fillStyle = '#FFA500';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(5, 5, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(-5, -5, 3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = '#FF8C00';
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(i * 5 - 5, i * 5 - 5, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (this.type === 4) { // Dragonfruit
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#32CD32';
                    for (let i = 0; i < 6; i++) {
                        let angle = (Math.PI * 2 / 6) * i;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                        ctx.lineTo(Math.cos(angle) * (this.radius + 8), Math.sin(angle) * (this.radius + 8));
                        ctx.strokeStyle = '#32CD32';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius - 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 5) { // Melón
                    ctx.fillStyle = '#98FB98';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#006400';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = '#006400';
                    for (let i = 0; i < 6; i++) {
                        let angle = (Math.PI * 2 / 6) * i;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * this.radius, -this.radius);
                        ctx.quadraticCurveTo(
                            Math.cos(angle) * this.radius * 0.5, 0,
                            Math.cos(angle) * this.radius, this.radius
                        );
                        ctx.stroke();
                    }
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.arc(10, 10, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else { // Sandía
                    ctx.fillStyle = '#FF4500';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#006400';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius - 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000000';
                    for (let i = 0; i < 5; i++) {
                        let angle = (Math.PI * 2 / 5) * i;
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle) * (this.radius - 10), Math.sin(angle) * (this.radius - 10), 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.moveTo(-this.radius + 5, 0);
                    ctx.lineTo(this.radius - 5, 0);
                    ctx.stroke();
                }
                ctx.restore();
            }

            update() {
                if (!this.isSettled) {
                    // Guardar velocidad antes del impacto
                    this.lastImpactVelocity = { x: this.vx, y: this.vy };

                    // Aplicar gravedad
                    this.vy = Math.min(this.vy + GRAVITY, TERMINAL_VELOCITY);
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= FRICTION;
                    this.vy *= FRICTION;

                    // Rotación
                    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    if (speed > 0.1 && this.bounceCount < 5) {
                        this.angle += this.angularVelocity;
                        this.angularVelocity = Math.max(-MAX_ANGULAR_VELOCITY, Math.min(MAX_ANGULAR_VELOCITY, this.angularVelocity));
                        this.angularVelocity *= FRICTION;
                    } else if (this.bounceCount >= 5) {
                        this.angularVelocity = 0;
                        this.isSettled = true;
                    }

                    // Colisión con paredes
                    if (this.x - this.radius * this.scale < 0) {
                        this.x = this.radius * this.scale;
                        this.vx = -this.lastImpactVelocity.x * this.getBounceFactor();
                        this.countBounce();
                    } else if (this.x + this.radius * this.scale > canvas.width) {
                        this.x = canvas.width - this.radius * this.scale;
                        this.vx = -this.lastImpactVelocity.x * this.getBounceFactor();
                        this.countBounce();
                    }

                    // Colisión con el suelo
                    if (this.y + this.radius * this.scale > canvas.height) {
                        this.y = canvas.height - this.radius * this.scale;
                        this.vy = -this.lastImpactVelocity.y * this.getBounceFactor();
                        this.countBounce();
                        if (this.bounceCount >= 5) {
                            this.vy = 0;
                            this.vx = 0;
                            this.isSettled = true;
                        }
                    }

                    // Asegurar que no se salga del área de juego
                    this.x = Math.max(this.radius * this.scale, Math.min(canvas.width - this.radius * this.scale, this.x));
                    this.y = Math.max(this.radius * this.scale, Math.min(canvas.height - this.radius * this.scale, this.y));
                }

                // Animaciones de escala
                if (this.shrinkSpeed > 0) {
                    this.scale -= this.shrinkSpeed;
                    if (this.scale <= 0) this.scale = 0;
                }
                if (this.growSpeed > 0) {
                    this.scale += this.growSpeed;
                    if (this.scale >= 1) this.scale = 1;
                }
            }

            getBounceFactor() {
                const factors = [0.5, 0.25, 0.125, 0.0625, 0.03125];
                return this.bounceCount < 5 ? factors[this.bounceCount] : 0;
            }

            countBounce() {
                const speed = Math.sqrt(this.lastImpactVelocity.x ** 2 + this.lastImpactVelocity.y ** 2);
                if (speed > 0.1) {
                    this.bounceCount = Math.min(this.bounceCount + 1, 5);
                }
            }
        }

        class Confetti {
            constructor(x, y, color, size = 4) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 60;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1;
                this.life--;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        let fruits = [];
        let confetti = [];
        let nextFruit = new Fruit(canvas.width / 2, 50, Math.floor(Math.random() * 4));
        let aimingX = canvas.width / 2;
        let isAiming = false;

        function spawnFruit() {
            fruits.push(new Fruit(aimingX, 50, nextFruit.type));
            nextFruit = new Fruit(aimingX, 50, Math.floor(Math.random() * 4));
        }

        function drawDashedLine() {
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#666';
            ctx.beginPath();
            ctx.moveTo(aimingX, 0);
            ctx.lineTo(aimingX, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function triggerConfettiExplosion(x, y, amount = 20, fruitType) {
            const colorSets = [
                ['#90EE90', '#FFFFFF', '#000000'],
                ['#FF4040', '#228B22', '#FFFFFF'],
                ['#800080', '#654321', '#DDA0DD'],
                ['#FFA500', '#FFD700', '#FF8C00'],
                ['#FF1493', '#32CD32', '#000000'],
                ['#98FB98', '#006400', '#8B4513'],
                ['#FF4500', '#006400', '#000000']
            ];
            const colors = colorSets[fruitType];
            for (let j = 0; j < amount; j++) {
                confetti.push(new Confetti(x, y, colors[Math.floor(Math.random() * colors.length)]));
            }
        }

        function checkCollisions() {
            for (let i = 0; i < fruits.length; i++) {
                for (let j = i + 1; j < fruits.length; j++) {
                    let f1 = fruits[i];
                    let f2 = fruits[j];
                    let dx = f2.x - f1.x;
                    let dy = f2.y - f1.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < (f1.radius * f1.scale + f2.radius * f2.scale) && f1.scale > 0 && f2.scale > 0) {
                        if (f1.type === f2.type) {
                            f1.shrinkSpeed = 0.1;
                            f2.shrinkSpeed = 0.1;
                            if (f1.type === 6) { // Sandías
                                setTimeout(() => {
                                    if (fruits.includes(f1)) fruits.splice(fruits.indexOf(f1), 1);
                                    if (fruits.includes(f2)) fruits.splice(fruits.indexOf(f2), 1);
                                    score++;
                                    scoreDisplay.textContent = `Puntaje: ${score}`;
                                    triggerConfettiExplosion(f1.x, f1.y, 40, 6);
                                    setTimeout(() => triggerConfettiExplosion(f1.x, f1.y, 40, 6), 300);
                                    setTimeout(() => triggerConfettiExplosion(f1.x, f1.y, 40, 6), 600);
                                }, 200);
                            } else { // Fusión
                                let newType = f1.type + 1;
                                let newX = (f1.x + f2.x) / 2;
                                let newY = (f1.y + f2.y) / 2;
                                setTimeout(() => {
                                    if (fruits.includes(f1) && fruits.includes(f2)) {
                                        fruits.splice(fruits.indexOf(f1), 1);
                                        fruits.splice(fruits.indexOf(f2), 1);
                                        let newFruit = new Fruit(newX, newY, newType, 0);
                                        newFruit.growSpeed = 0.1;
                                        fruits.push(newFruit);
                                        triggerConfettiExplosion(newX, newY, 20, f1.type);
                                    }
                                }, 200);
                            }
                            return;
                        } else {
                            // Guardar velocidades pre-colisión
                            f1.lastImpactVelocity = { x: f1.vx, y: f1.vy };
                            f2.lastImpactVelocity = { x: f2.vx, y: f2.vy };

                            // Física de colisión elástica
                            let angle = Math.atan2(dy, dx);
                            let sin = Math.sin(angle);
                            let cos = Math.cos(angle);

                            let vx1 = f1.vx * cos + f1.vy * sin;
                            let vy1 = f1.vy * cos - f1.vx * sin;
                            let vx2 = f2.vx * cos + f2.vy * sin;
                            let vy2 = f2.vy * cos - f2.vx * sin;

                            let finalVx1 = ((f1.mass - f2.mass) * vx1 + 2 * f2.mass * vx2) / (f1.mass + f2.mass);
                            let finalVx2 = ((f2.mass - f1.mass) * vx2 + 2 * f1.mass * vx1) / (f1.mass + f2.mass);

                            // Aplicar factor de rebote
                            let bounceFactor1 = f1.getBounceFactor();
                            let bounceFactor2 = f2.getBounceFactor();
                            f1.vx = (cos * finalVx1 - sin * vy1) * bounceFactor1;
                            f1.vy = (sin * finalVx1 + cos * vy1) * bounceFactor1;
                            f2.vx = (cos * finalVx2 - sin * vy2) * bounceFactor2;
                            f2.vy = (sin * finalVx2 + cos * vy2) * bounceFactor2;

                            // Separar frutas para evitar solapamiento
                            let overlap = (f1.radius * f1.scale + f2.radius * f2.scale) - distance;
                            let separation = overlap / distance / 2;
                            f1.x -= dx * separation;
                            f1.y -= dy * separation;
                            f2.x += dx * separation;
                            f2.y += dy * separation;

                            // Contar rebotes y aplicar rotación
                            f1.countBounce();
                            f2.countBounce();
                            if (!f1.isSettled) f1.angularVelocity += (f2.vx - f1.vx) * 0.03 / f1.radius;
                            if (!f2.isSettled) f2.angularVelocity -= (f1.vx - f2.vx) * 0.03 / f2.radius;

                            // Apagar micromovimientos después de 5 rebotes
                            if (f1.bounceCount >= 5 && Math.abs(f1.vx) < 0.1 && Math.abs(f1.vy) < 0.1) {
                                f1.vx = 0;
                                f1.vy = 0;
                                f1.isSettled = true;
                            }
                            if (f2.bounceCount >= 5 && Math.abs(f2.vx) < 0.1 && Math.abs(f2.vy) < 0.1) {
                                f2.vx = 0;
                                f2.vy = 0;
                                f2.isSettled = true;
                            }
                        }
                    }
                }
            }
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            fruits.forEach(fruit => {
                fruit.update();
                if (fruit.scale > 0) fruit.draw();
            });

            confetti.forEach((c, i) => {
                c.update();
                c.draw();
                if (c.life <= 0) confetti.splice(i, 1);
            });

            if (isAiming) drawDashedLine();
            nextFruit.x = aimingX;
            nextFruit.draw();

            checkCollisions();

            requestAnimationFrame(gameLoop);
        }

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isAiming = true;
            aimingX = Math.max(nextFruit.radius, Math.min(canvas.width - nextFruit.radius, e.touches[0].clientX - canvas.offsetLeft));
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isAiming) {
                aimingX = Math.max(nextFruit.radius, Math.min(canvas.width - nextFruit.radius, e.touches[0].clientX - canvas.offsetLeft));
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (isAiming) {
                spawnFruit();
                isAiming = false;
            }
        });

        gameLoop();
    </script>
</body>
</html>