<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Frutas con Peso</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #87CEEB;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #333;
            background-color: #F5F5F5;
            touch-action: none;
        }
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #333;
            font-size: 20px;
            font-weight: bold;
        }
        #lives {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            font-size: 24px;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Puntaje: 0</div>
    <div id="lives">❤️❤️❤️</div>
    <div id="gameOver">Fin!<br>Hiciste <span id="finalScore">0</span> puntos.</div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const gameOverDisplay = document.getElementById('gameOver');
        const finalScoreDisplay = document.getElementById('finalScore');

        canvas.width = Math.min(window.innerWidth * 0.9, 400);
        canvas.height = Math.min(window.innerHeight * 0.9, 600) - 50;

        const GRAVITY = 0.98;
        const TERMINAL_VELOCITY = 20;
        const BASE_BOUNCE_WALL = 0.7;
        const BASE_BOUNCE_FLOOR = 0.6;
        const BASE_FRICTION = 0.92;
        const FINAL_FRICTION = 0.3;
        const ROTATION_FRICTION = 0.95;
        const MAX_ANGULAR_VELOCITY = 2 * Math.PI / 60;
        const FREEZE_DELAY = 1500; // 1.5 segundos de movimiento post-colisión
        const FREEZE_DURATION = 500; // 0.5 segundos de congelamiento gradual
        const MAX_COLLISION_VELOCITY = 10;

        let score = 0;
        let lives = 3;
        let lastSpawnTime = Date.now();
        let gameOver = false;

        class Fruit {
            constructor(x, y, type, scale = 1) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = [8, 10, 15, 24, 33, 42, 51, 60][type] * 1.44;
                this.mass = [0.5, 1, 2, 4, 8, 16, 32, 64][type];
                this.vx = 0;
                this.vy = 0;
                this.scale = scale;
                this.shrinkSpeed = 0;
                this.growSpeed = 0;
                this.angle = 0;
                this.angularVelocity = (Math.random() - 0.5) * 0.15;
                this.isFrozen = false;
                this.isMerging = false;
                this.lastPerturbedTime = Date.now();
                this.initialEnergy = GRAVITY * canvas.height;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                ctx.rotate(this.angle);
                if (this.type === 0) { // Arándano
                    ctx.fillStyle = '#1E90FF';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(2, -2, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.arc(0, 1, this.radius - 1, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 1) { // Uvas
                    ctx.fillStyle = '#90EE90';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(3, -3, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.arc(0, 2, this.radius - 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 2) { // Cereza
                    ctx.fillStyle = '#FF4040';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.moveTo(0, -this.radius);
                    ctx.lineTo(5, -this.radius - 10);
                    ctx.lineTo(-5, -this.radius - 15);
                    ctx.fill();
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(5, 5, 3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.arc(0, 5, this.radius - 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 3) { // Ciruela
                    ctx.fillStyle = '#800080';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.arc(0, -this.radius + 5, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#DDA0DD';
                    ctx.beginPath();
                    ctx.arc(-5, 5, 4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(8, -8, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 4) { // Naranja
                    ctx.fillStyle = '#FFA500';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(5, 5, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(-5, -5, 3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = '#FF8C00';
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(i * 5 - 5, i * 5 - 5, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (this.type === 5) { // Dragonfruit
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#32CD32';
                    for (let i = 0; i < 6; i++) {
                        let angle = (Math.PI * 2 / 6) * i;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                        ctx.lineTo(Math.cos(angle) * (this.radius + 8), Math.sin(angle) * (this.radius + 8));
                        ctx.strokeStyle = '#32CD32';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius - 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 6) { // Melón
                    ctx.fillStyle = '#98FB98';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#006400';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = '#006400';
                    for (let i = 0; i < 6; i++) {
                        let angle = (Math.PI * 2 / 6) * i;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * this.radius * 0.8, -this.radius * 0.8);
                        ctx.quadraticCurveTo(
                            Math.cos(angle) * this.radius * 0.4, 0,
                            Math.cos(angle) * this.radius * 0.8, this.radius * 0.8
                        );
                        ctx.stroke();
                    }
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.arc(10, 10, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else { // Sandía
                    ctx.fillStyle = '#FF4500';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#006400';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius - 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000000';
                    for (let i = 0; i < 5; i++) {
                        let angle = (Math.PI * 2 / 5) * i;
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle) * (this.radius - 10), Math.sin(angle) * (this.radius - 10), 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.moveTo(-this.radius + 5, 0);
                    ctx.lineTo(this.radius - 5, 0);
                    ctx.stroke();
                }
                ctx.restore();
            }

            update() {
                if (gameOver || this.isFrozen) {
                    this.angularVelocity = 0;
                    this.vx = 0;
                    this.vy = 0;
                    return;
                }

                this.vy = Math.min(this.vy + GRAVITY, TERMINAL_VELOCITY);
                this.x += this.vx;
                this.y += this.vy;

                const timeSinceLastPerturbed = Date.now() - this.lastPerturbedTime;
                let friction;
                if (timeSinceLastPerturbed > FREEZE_DELAY + FREEZE_DURATION) {
                    this.isFrozen = true;
                    this.vx = 0;
                    this.vy = 0;
                    this.angularVelocity = 0;
                    return;
                } else if (timeSinceLastPerturbed > FREEZE_DELAY) {
                    const progress = (timeSinceLastPerturbed - FREEZE_DELAY) / FREEZE_DURATION;
                    friction = BASE_FRICTION - (BASE_FRICTION - FINAL_FRICTION) * progress;
                } else {
                    friction = BASE_FRICTION - (this.mass / 64) * 0.1;
                }

                this.vx *= friction;
                this.vy *= friction;

                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 0.1 || Math.abs(this.angularVelocity) > 0.01) {
                    this.angle += this.angularVelocity;
                    this.angularVelocity = Math.max(-MAX_ANGULAR_VELOCITY, Math.min(MAX_ANGULAR_VELOCITY, this.angularVelocity));
                    this.angularVelocity *= friction;
                } else {
                    this.angularVelocity = 0;
                }

                const bounceFloor = BASE_BOUNCE_FLOOR * (1 - this.mass / 64 * 0.5);
                const bounceWall = BASE_BOUNCE_WALL * (1 - this.mass / 64 * 0.5);
                if (this.x - this.radius * this.scale < 0) {
                    this.x = this.radius * this.scale;
                    this.vx = Math.min(Math.abs(this.vx) * bounceWall, Math.sqrt(this.initialEnergy)) * Math.sign(this.vx);
                } else if (this.x + this.radius * this.scale > canvas.width) {
                    this.x = canvas.width - this.radius * this.scale;
                    this.vx = Math.min(Math.abs(this.vx) * bounceWall, Math.sqrt(this.initialEnergy)) * Math.sign(this.vx);
                }
                if (this.y + this.radius * this.scale > canvas.height) {
                    this.y = canvas.height - this.radius * this.scale;
                    this.vy = -Math.min(Math.abs(this.vy) * bounceFloor, Math.sqrt(this.initialEnergy));
                    if (Math.abs(this.vy) < 0.5) this.vy = 0; ​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​