<!DOCTYPE html>
<html lang="es">
<head>
    <!-- Tu head original sin cambios -->
</head>
<body>
    <!-- Tu body original sin cambios -->
    <script>
        // Constantes y configuraciones existentes sin cambios
        const TRICK_PROBABILITY = 0.2; // 20% de probabilidad de que una fruta fusionada tenga truco

        class Fruit {
            constructor(x, y, type, scale = 1) {
                // Propiedades existentes
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = [8, 10, 15, 24, 33, 42, 51, 60][type] * 1.44;
                this.mass = [0.5, 1, 2, 4, 8, 16, 32, 64][type];
                this.vx = 0;
                this.vy = 0;
                this.scale = scale;
                this.shrinkSpeed = 0;
                this.growSpeed = 0;
                this.angle = 0;
                this.angularVelocity = (Math.random() - 0.5) * 0.1;
                this.isFrozen = false;
                this.isMerging = false;
                this.lastPerturbedTime = Date.now();
                // Nueva propiedad para truquitos
                this.hasTrick = 0; // 0 = sin truco, 1 = -5s, 2 = ❤️, 3 = 🍉
            }

            draw(context = ctx) {
                context.save();
                context.translate(this.x, this.y);
                context.scale(this.scale, this.scale);
                context.rotate(this.angle);

                // Dibujo de la fruta (sin cambios en esta parte)
                if (useImages && allImagesLoaded) {
                    const img = fruitImages[this.type];
                    const size = this.radius * 2;
                    context.drawImage(img, -this.radius, -this.radius, size, size);
                } else {
                    // Lógica de dibujo existente (sin cambios)
                    const baseColors = [
                        '#1E90FF', '#90EE90', '#FF4040', '#800080',
                        '#FFA500', '#FF1493', '#98FB98', '#FF4500'
                    ];
                    context.fillStyle = baseColors[this.type];
                    context.beginPath();
                    context.arc(0, 0, this.radius, 0, Math.PI * 2);
                    context.fill();
                    // Detalles específicos por tipo (sin cambios)
                }

                // Dibujar el truco si existe
                if (this.hasTrick > 0) {
                    context.font = "20px Arial";
                    context.fillStyle = "#FFFFFF";
                    context.textAlign = "center";
                    context.textBaseline = "middle";
                    const trickIcons = ["", "-5s", "❤️", "🍉"];
                    context.fillText(trickIcons[this.hasTrick], 0, 0);
                }

                context.restore();
            }

            // Método update sin cambios
        }

        // Clase BonusText ya existente, se usará para animaciones

        // Variables existentes
        let fruits = [];
        let liquidDrops = [];
        let bonusTexts = [];
        let nextFruit = new Fruit(canvas.width / 2, 50, Math.floor(Math.random() * 3));
        let aimingX = canvas.width / 2;
        let isAiming = false;

        // Función para asignar un truco aleatorio a una fruta fusionada
        function assignRandomTrick(fruit) {
            if (fruit.type >= 2 && Math.random() < TRICK_PROBABILITY) { // Desde naranja (tipo 2)
                fruit.hasTrick = Math.floor(Math.random() * 3) + 1; // 1, 2 o 3
            }
        }

        // Modificar spawnFruit (sin cambios significativos, solo para referencia)
        function spawnFruit() {
            if (gameOver || !gameStarted) return;
            const randomOffset = (Math.random() - 0.5) * 4;
            let spawnX = Math.max(nextFruit.radius, Math.min(canvas.width - nextFruit.radius, aimingX + randomOffset));
            let newFruit = new Fruit(spawnX, 50, nextFruit.type);
            fruits.push(newFruit);
            nextFruit = new Fruit(aimingX, 50, Math.floor(Math.random() * 3));
            lastSpawnTime = Date.now();
            score--;
            scoreDisplay.textContent = `Puntaje: ${score}`;
            scoreDisplay.classList.remove('pulse');
        }

        // Modificar checkCollisions para asignar trucos a frutas fusionadas
        function checkCollisions() {
            if (gameOver || !gameStarted) return;
            for (let i = 0; i < fruits.length; i++) {
                for (let j = i + 1; j < fruits.length; j++) {
                    let f1 = fruits[i];
                    let f2 = fruits[j];
                    let dx = f2.x - f1.x;
                    let dy = f2.y - f1.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    let minDistance = f1.radius * f1.scale + f2.radius * f2.scale;

                    if (distance < minDistance && f1.scale >= 0.9 && f2.scale >= 0.9) {
                        // Lógica de colisión existente
                        if (f1.type === f2.type && !f1.isMerging && !f2.isMerging) {
                            f1.isMerging = true;
                            f2.isMerging = true;
                            f1.shrinkSpeed = 0.1;
                            f2.shrinkSpeed = 0.1;
                            if (f1.type === 7) {
                                setTimeout(() => {
                                    const index1 = fruits.indexOf(f1);
                                    const index2 = fruits.indexOf(f2);
                                    if (index1 !== -1 && index2 !== -1) {
                                        fruits.splice(index1, 1);
                                        fruits.splice(index2 > index1 ? index2 - 1 : index2, 1);
                                        if (lives < MAX_LIVES) {
                                            lives++;
                                            updateLivesDisplay();
                                        }
                                        triggerLiquidExplosion(f1.x, f1.y, 40, 7);
                                        setTimeout(() => triggerLiquidExplosion(f1.x, f1.y, 40, 7), 200);
                                        setTimeout(() => triggerLiquidExplosion(f1.x, f1.y, 40, 7), 400);
                                        score += 3;
                                        bonusTexts.push(new BonusText(f1.x, f1.y, "+3"));
                                        scoreDisplay.textContent = `Puntaje: ${score}`;
                                        scoreDisplay.classList.add('scoreAdd');
                                        setTimeout(() => scoreDisplay.classList.remove('scoreAdd'), 500);
                                    }
                                }, 100);
                            } else {
                                let newType = f1.type + 1;
                                let newX = (f1.x + f2.x) / 2;
                                let newY = (f1.y + f2.y) / 2;
                                setTimeout(() => {
                                    const index1 = fruits.indexOf(f1);
                                    const index2 = fruits.indexOf(f2);
                                    if (index1 !== -1 && index2 !== -1) {
                                        fruits.splice(index1, 1);
                                        fruits.splice(index2 > index1 ? index2 - 1 : index2, 1);
                                        let newFruit = new Fruit(newX, newY, newType, 0);
                                        newFruit.growSpeed = 0.1;
                                        newFruit.angularVelocity = (Math.random() - 0.5) * 0.1;
                                        assignRandomTrick(newFruit); // Asignar truco aquí
                                        fruits.push(newFruit);
                                        triggerLiquidExplosion(newX, newY, 20, f1.type);
                                        if (newType === 5) {
                                            score += 1;
                                            bonusTexts.push(new BonusText(newX, newY, "+1"));
                                            scoreDisplay.classList.add('scoreAdd');
                                            setTimeout(() => scoreDisplay.classList.remove('scoreAdd'), 500);
                                        } else if (newType === 6) {
                                            score += 2;
                                            bonusTexts.push(new BonusText(newX, newY, "+2"));
                                            scoreDisplay.classList.add('scoreAdd');
                                            setTimeout(() => scoreDisplay.classList.remove('scoreAdd'), 500);
                                        }
                                        scoreDisplay.textContent = `Puntaje: ${score}`;
                                    }
                                }, 100);
                            }
                        } else {
                            // Lógica de colisión física sin cambios
                        }
                    }
                }
            }
        }

        // Función para aplicar el efecto del truco
        function applyTrick(fruit) {
            switch (fruit.hasTrick) {
                case 1: // -5s
                    gameTime = Math.max(0, gameTime - 5);
                    timerDisplay.textContent = `Tiempo: ${gameTime}s`;
                    timerDisplay.classList.add('pulseGreen');
                    setTimeout(() => timerDisplay.classList.remove('pulseGreen'), 500);
                    bonusTexts.push(new BonusText(fruit.x, fruit.y, "-5s"));
                    break;
                case 2: // ❤️
                    if (lives < MAX_LIVES) {
                        lives++;
                        updateLivesDisplay();
                        livesDisplay.classList.add('lifeLost');
                        setTimeout(() => livesDisplay.classList.remove('lifeLost'), 500);
                        bonusTexts.push(new BonusText(fruit.x, fruit.y, "+1 vida"));
                    }
                    break;
                case 3: // 🍉
                    nextFruit = new Fruit(aimingX, 50, 7); // Sandía
                    nextFruit.scale = 1; // Asegurar tamaño normal
                    ctx.save();
                    ctx.translate(nextFruit.x, nextFruit.y);
                    ctx.scale(1.2, 1.2);
                    nextFruit.draw();
                    ctx.restore();
                    setTimeout(() => nextFruit.scale = 1, 500); // Breve animación
                    bonusTexts.push(new BonusText(fruit.x, fruit.y, "¡Sandía!"));
                    break;
            }
            triggerLiquidExplosion(fruit.x, fruit.y, 15, fruit.type); // Efecto visual al tocar
            fruits.splice(fruits.indexOf(fruit), 1); // Eliminar la fruta
        }

        // Modificar eventos para detectar toques en frutas con trucos
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameOver && gameStarted) {
                const touchX = e.touches[0].clientX - canvas.offsetLeft;
                const touchY = e.touches[0].clientY - canvas.offsetTop;
                const fruit = fruits.find(f => 
                    f.hasTrick > 0 &&
                    Math.sqrt((f.x - touchX) ** 2 + (f.y - touchY) ** 2) < f.radius * f.scale
                );
                if (fruit) {
                    applyTrick(fruit);
                } else {
                    isAiming = true;
                    aimingX = Math.max(nextFruit.radius, Math.min(canvas.width - nextFruit.radius, touchX));
                }
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (!gameOver && gameStarted) {
                const clickX = e.clientX - canvas.offsetLeft;
                const clickY = e.clientY - canvas.offsetTop;
                const fruit = fruits.find(f => 
                    f.hasTrick > 0 &&
                    Math.sqrt((f.x - clickX) ** 2 + (f.y - clickY) ** 2) < f.radius * f.scale
                );
                if (fruit) {
                    applyTrick(fruit);
                } else {
                    isAiming = true;
                    aimingX = Math.max(nextFruit.radius, Math.min(canvas.width - nextFruit.radius, clickX));
                }
            }
        });

        // Resto del código (gameLoop, updateTimer, etc.) sin cambios
    </script>
</body>
</html>