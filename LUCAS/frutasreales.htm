<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Frutas con Peso</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #87CEEB;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #333;
            background-color: #F5F5F5;
            touch-action: none;
        }
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #333;
            font-size: 20px;
            font-weight: bold;
            transition: color 0.5s ease-in-out;
        }
        #score.pulse {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); color: #FF0000; }
            50% { transform: scale(1.2); color: #FF4444; }
        }
        #score.scoreAdd {
            animation: scoreAdd 0.5s ease-out;
        }
        @keyframes scoreAdd {
            0% { transform: scale(1); color: #333; }
            50% { transform: scale(1.3); color: #00FF00; }
            100% { transform: scale(1); color: #333; }
        }
        #score.scoreZero {
            animation: scoreZero 0.5s ease-out;
        }
        @keyframes scoreZero {
            0% { transform: scale(1); color: #333; }
            25% { transform: scale(1.5) translateX(-5px); color: #FF0000; }
            50% { transform: scale(1.5) translateX(5px); color: #FF0000; }
            100% { transform: scale(1); color: #333; }
        }
        #lives {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
        }
        #lives.lifeLost {
            animation: lifeLost 0.5s ease-out;
        }
        @keyframes lifeLost {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: #FF0000; }
            100% { transform: scale(1); color: #000; }
        }
        #timer {
            position: absolute;
            top: 40px;
            right: 10px;
            color: #333;
            font-size: 20px;
            font-weight: bold;
        }
        #timer.pulseGreen {
            animation: pulseGreen 1s infinite;
        }
        @keyframes pulseGreen {
            0%, 100% { transform: scale(1); color: #00FF00; }
            50% { transform: scale(1.2); color: #00CC00; }
        }
        #fruitOrder {
            position: absolute;
            top: 40px;
            left: 10px;
            display: flex;
            gap: 2px;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            font-size: 24px;
            text-align: center;
            display: none;
        }
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            font-size: 14px;
            text-align: center;
            width: 80%;
            max-width: 600px;
        }
        #startButton {
            margin-top: 10px;
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #startButton:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Puntaje: 50</div>
    <div id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
    <div id="timer">Tiempo: 180s</div>
    <div id="fruitOrder"></div>
    <div id="gameOver"><span id="gameResult">Fin!</span><br>Puntuaci√≥n: <span id="finalScore">0</span></div>
    <div id="startScreen">
        <h2>¬°Bienvenido al Juego de Frutas!</h2>
        <p>Reglas:</p>
        <ul style="text-align: left; padding-left: 20px;">
            <li>Tienes 5 vidas iniciales (m√°ximo 5).</li>
            <li>Cada fruta que tires resta 1 punto.</li>
            <li>Si no tiras frutas por 3 segundos, el puntaje late en rojo y pierdes 5 puntos por segundo.</li>
            <li>Fusiona frutas iguales para crear una mayor.</li>
            <li>Bonus: +1 por dragonfruit, +2 por mel√≥n, +3 por sand√≠a.</li>
            <li>Fusionar sand√≠as te da una vida extra.</li>
            <li>Ganas si el temporizador de 3 minutos llega a 0. Puntuaci√≥n: vidas restantes √ó puntaje.</li>
            <li>Pierdes si te quedas sin vidas, y tu puntuaci√≥n ser√° 0.</li>
        </ul>
        <button id="startButton">Comenzar</button>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const timerDisplay = document.getElementById('timer');
        const fruitOrderDisplay = document.getElementById('fruitOrder');
        const gameOverDisplay = document.getElementById('gameOver');
        const gameResultDisplay = document.getElementById('gameResult');
        const finalScoreDisplay = document.getElementById('finalScore');
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');

        canvas.width = Math.min(window.innerWidth * 0.9, 400);
        canvas.height = Math.min(window.innerHeight * 0.9, 600) - 50;

        const GRAVITY = 0.98;
        const TERMINAL_VELOCITY = 20;
        const BASE_BOUNCE_WALL = 0.3;
        const BASE_BOUNCE_FLOOR = 0.2;
        const BASE_FRICTION = 0.98;
        const FINAL_FRICTION = 0.85;
        const ROTATION_FRICTION = 0.95;
        const MAX_ANGULAR_VELOCITY = 2 * Math.PI / 60;
        const FREEZE_DELAY = 3000;
        const FREEZE_DURATION = 1000;
        const INITIAL_SCORE = 50;
        const INITIAL_LIVES = 5;
        const MAX_LIVES = 5;
        const GAME_DURATION = 180;
        const INACTIVITY_THRESHOLD = 3000;
        const TRICK_PROBABILITY = 0.2; // 20% de probabilidad de truco

        let score = INITIAL_SCORE;
        let lives = INITIAL_LIVES;
        let gameTime = GAME_DURATION;
        let lastSpawnTime = Date.now();
        let gameOver = false;
        let gameStarted = false;
        let useImages = true;
        let gameStartTime;

        const fruitImages = {};
        const fruitTypes = 8;
        let imagesLoaded = 0;
        let allImagesLoaded = false;

        function loadFruitImages() {
            for (let i = 0; i < fruitTypes; i++) {
                fruitImages[i] = new Image();
                fruitImages[i].src = `images/fruit${i}.png`;
                fruitImages[i].onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === fruitTypes) allImagesLoaded = true;
                };
                fruitImages[i].onerror = () => {
                    console.error(`Error al cargar fruit${i}.png`);
                    useImages = false;
                };
            }
        }
        loadFruitImages();

        class Fruit {
            constructor(x, y, type, scale = 1) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = [8, 10, 15, 24, 33, 42, 51, 60][type] * 1.44;
                this.mass = [0.5, 1, 2, 4, 8, 16, 32, 64][type];
                this.vx = 0;
                this.vy = 0;
                this.scale = scale;
                this.shrinkSpeed = 0;
                this.growSpeed = 0;
                this.angle = 0;
                this.angularVelocity = (Math.random() - 0.5) * 0.1;
                this.isFrozen = false;
                this.isMerging = false;
                this.lastPerturbedTime = Date.now();
                this.hasTrick = 0; // 0 = sin truco, 1 = -5s, 2 = ‚ù§Ô∏è, 3 = üçâ
            }

            draw(context = ctx) {
                context.save();
                context.translate(this.x, this.y);
                context.scale(this.scale, this.scale);
                context.rotate(this.angle);

                if (useImages && allImagesLoaded) {
                    const img = fruitImages[this.type];
                    const size = this.radius * 2;
                    context.drawImage(img, -this.radius, -this.radius, size, size);
                } else {
                    const baseColors = [
                        '#1E90FF', '#90EE90', '#FF4040', '#800080',
                        '#FFA500', '#FF1493', '#98FB98', '#FF4500'
                    ];
                    context.fillStyle = baseColors[this.type];
                    context.beginPath();
                    context.arc(0, 0, this.radius, 0, Math.PI * 2);
                    context.fill();

                    if (this.type === 0) {
                        context.fillStyle = '#FFFFFF';
                        context.beginPath();
                        context.arc(2, -2, 1.5, 0, Math.PI * 2);
                        context.fill();
                        context.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        context.beginPath();
                        context.arc(0, 1, this.radius - 1, 0, Math.PI * 2);
                        context.fill();
                    } else if (this.type === 1) {
                        context.fillStyle = '#FFFFFF';
                        context.beginPath();
                        context.arc(3, -3, 2, 0, Math.PI * 2);
                        context.fill();
                        context.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        context.beginPath();
                        context.arc(0, 2, this.radius - 2, 0, Math.PI * 2);
                        context.fill();
                    } else if (this.type === 2) {
                        context.fillStyle = '#228B22';
                        context.beginPath();
                        context.moveTo(0, -this.radius);
                        context.lineTo(5, -this.radius - 10);
                        context.lineTo(-5, -this.radius - 15);
                        context.fill();
                        context.strokeStyle = '#FFFFFF';
                        context.beginPath();
                        context.arc(5, 5, 3, 0, Math.PI * 2);
                        context.stroke();
                        context.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        context.beginPath();
                        context.arc(0, 5, this.radius - 5, 0, Math.PI * 2);
                        context.fill();
                    } else if (this.type === 3) {
                        context.fillStyle = '#654321';
                        context.beginPath();
                        context.arc(0, -this.radius + 5, 5, 0, Math.PI * 2);
                        context.fill();
                        context.strokeStyle = '#DDA0DD';
                        context.beginPath();
                        context.arc(-5, 5, 4, 0, Math.PI * 2);
                        context.stroke();
                        context.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        context.beginPath();
                        context.arc(8, -8, 5, 0, Math.PI * 2);
                        context.fill();
                    } else if (this.type === 4) {
                        context.fillStyle = '#FFD700';
                        context.beginPath();
                        context.arc(5, 5, 5, 0, Math.PI * 2);
                        context.fill();
                        context.beginPath();
                        context.arc(-5, -5, 3, 0, Math.PI * 2);
                        context.stroke();
                        context.fillStyle = '#FF8C00';
                        for (let i = 0; i < 3; i++) {
                            context.beginPath();
                            context.arc(i * 5 - 5, i * 5 - 5, 2, 0, Math.PI * 2);
                            context.fill();
                        }
                    } else if (this.type === 5) {
                        context.fillStyle = '#32CD32';
                        for (let i = 0; i < 6; i++) {
                            let angle = (Math.PI * 2 / 6) * i;
                            context.beginPath();
                            context.moveTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                            context.lineTo(Math.cos(angle) * (this.radius + 8), Math.sin(angle) * (this.radius + 8));
                            context.strokeStyle = '#32CD32';
                            context.lineWidth = 3;
                            context.stroke();
                        }
                        context.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        context.beginPath();
                        context.arc(0, 0, this.radius - 5, 0, Math.PI * 2);
                        context.fill();
                    } else if (this.type === 6) {
                        context.strokeStyle = '#006400';
                        context.lineWidth = 2;
                        context.beginPath();
                        context.arc(0, 0, this.radius, 0, Math.PI * 2);
                        context.stroke();
                        context.strokeStyle = '#006400';
                        for (let i = 0; i < 6; i++) {
                            let angle = (Math.PI * 2 / 6) * i;
                            context.beginPath();
                            context.moveTo(Math.cos(angle) * this.radius * 0.8, -this.radius * 0.8);
                            context.quadraticCurveTo(
                                Math.cos(angle) * this.radius * 0.4, 0,
                                Math.cos(angle) * this.radius * 0.8, this.radius * 0.8
                            );
                            context.stroke();
                        }
                        context.fillStyle = '#8B4513';
                        context.beginPath();
                        context.arc(10, 10, 3, 0, Math.PI * 2);
                        context.fill();
                    } else {
                        context.fillStyle = '#006400';
                        context.beginPath();
                        context.arc(0, 0, this.radius - 5, 0, Math.PI * 2);
                        context.fill();
                        context.fillStyle = '#000000';
                        for (let i = 0; i < 5; i++) {
                            let angle = (Math.PI * 2 / 5) * i;
                            context.beginPath();
                            context.arc(Math.cos(angle) * (this.radius - 10), Math.sin(angle) * (this.radius - 10), 2, 0, Math.PI * 2);
                            context.fill();
                        }
                        context.strokeStyle = '#FFFFFF';
                        context.beginPath();
                        context.moveTo(-this.radius + 5, 0);
                        context.lineTo(this.radius - 5, 0);
                        context.stroke();
                    }
                }

                // Dibujar el truco si existe
                if (this.hasTrick > 0) {
                    context.font = "20px Arial";
                    context.fillStyle = "#FFFFFF";
                    context.textAlign = "center";
                    context.textBaseline = "middle";
                    const trickIcons = ["", "-5s", "‚ù§Ô∏è", "üçâ"];
                    context.fillText(trickIcons[this.hasTrick], 0, 0);
                }

                context.restore();
            }

            update() {
                if (gameOver || this.isFrozen || !gameStarted) {
                    this.angularVelocity = 0;
                    this.vx = 0;
                    this.vy = 0;
                    return;
                }

                this.vy = Math.min(this.vy + GRAVITY, TERMINAL_VELOCITY);
                this.x += this.vx;
                this.y += this.vy;

                const timeSinceLastPerturbed = Date.now() - this.lastPerturbedTime;
                let friction = BASE_FRICTION;

                if (timeSinceLastPerturbed > FREEZE_DELAY + FREEZE_DURATION) {
                    this.isFrozen = true;
                    this.vx = 0;
                    this.vy = 0;
                    this.angularVelocity = 0;
                    return;
                } else if (timeSinceLastPerturbed > FREEZE_DELAY) {
                    const progress = (timeSinceLastPerturbed - FREEZE_DELAY) / FREEZE_DURATION;
                    friction = BASE_FRICTION - (BASE_FRICTION - FINAL_FRICTION) * progress;
                }

                this.vx *= friction;
                this.vy *= friction;

                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 0.1 || Math.abs(this.angularVelocity) > 0.01) {
                    this.angle += this.angularVelocity;
                    this.angularVelocity = Math.max(-MAX_ANGULAR_VELOCITY, Math.min(MAX_ANGULAR_VELOCITY, this.angularVelocity * ROTATION_FRICTION));
                } else {
                    this.angularVelocity = 0;
                }

                if (this.x - this.radius * this.scale < 0) {
                    this.x = this.radius * this.scale;
                    this.vx = Math.abs(this.vx) * BASE_BOUNCE_WALL;
                    this.angularVelocity += this.vy * 0.02 / this.mass;
                } else if (this.x + this.radius * this.scale > canvas.width) {
                    this.x = canvas.width - this.radius * this.scale;
                    this.vx = -Math.abs(this.vx) * BASE_BOUNCE_WALL;
                    this.angularVelocity -= this.vy * 0.02 / this.mass;
                }
                if (this.y + this.radius * this.scale > canvas.height) {
                    this.y = canvas.height - this.radius * this.scale;
                    this.vy = -Math.abs(this.vy) * BASE_BOUNCE_FLOOR;
                    this.angularVelocity += this.vx * 0.02 / this.mass;
                    if (Math.abs(this.vy) < 0.1) this.vy = 0;
                }
                if (this.y - this.radius * this.scale < 0) {
                    this.y = this.radius * this.scale;
                    this.vy = Math.abs(this.vy) * BASE_BOUNCE_FLOOR;
                    this.angularVelocity -= this.vx * 0.02 / this.mass;
                    if (lives > 0) {
                        lives--;
                        updateLivesDisplay();
                        if (lives === 0) {
                            endGame(false);
                        }
                    }
                }

                this.x = Math.max(this.radius * this.scale, Math.min(canvas.width - this.radius * this.scale, this.x));
                this.y = Math.max(this.radius * this.scale, Math.min(canvas.height - this.radius * this.scale, this.y));

                if (this.shrinkSpeed > 0) {
                    this.scale -= this.shrinkSpeed;
                    if (this.scale <= 0) this.scale = 0;
                }
                if (this.growSpeed > 0) {
                    this.scale += this.growSpeed;
                    if (this.scale >= 1) this.scale = 1;
                }
            }
        }

        class LiquidDrop {
            constructor(x, y, color, size = Math.random() * 4 + 2) {
                this.x = x;
                this.y = y;
                this.prevX = x;
                this.prevY = y;
                this.color = color;
                this.size = size;
                this.vx = (Math.random() - 0.5) * 12;
                this.vy = (Math.random() - 0.5) * 12;
                this.life = 60;
                this.initialSize = size;
            }

            update() {
                this.prevX = this.x;
                this.prevY = this.y;
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.9;
                this.vy *= 0.9;
                this.size = this.initialSize * (this.life / 60);
                this.life--;
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.prevX, this.prevY);
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = `${this.color}80`;
                ctx.lineWidth = this.size * 0.5;
                ctx.stroke();

                ctx.fillStyle = `${this.color}${Math.floor((this.life / 60) * 255).toString(16).padStart(2, '0')}`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class BonusText {
            constructor(x, y, text) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.life = 60;
                this.scale = 1;
                this.opacity = 1;
            }

            update() {
                this.scale = 1 + (1.5 - 1) * (1 - this.life / 60);
                this.opacity = this.life / 60;
                this.life--;
            }

            draw() {
                ctx.save();
                ctx.font = "20px Arial";
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.scale(this.scale, this.scale);
                ctx.fillText(this.text, this.x / this.scale, this.y / this.scale);
                ctx.restore();
            }
        }

        let fruits = [];
        let liquidDrops = [];
        let bonusTexts = [];
        let nextFruit = new Fruit(canvas.width / 2, 50, Math.floor(Math.random() * 3));
        let aimingX = canvas.width / 2;
        let isAiming = false;

        function drawFruitOrder() {
            const fruitOrderCanvas = document.createElement('canvas');
            const fruitCtx = fruitOrderCanvas.getContext('2d');
            const maxSize = 24;
            const baseRadius = 10;
            const relativeRadii = [0.5, 0.625, 1, 1.5, 2, 2.5, 3, 3.5];
            const slotSize = maxSize;
            const padding = 2;

            fruitOrderCanvas.width = slotSize * 8 + padding * 2;
            fruitOrderCanvas.height = slotSize + padding * 2;
            fruitCtx.fillStyle = '#87CEEB';
            fruitCtx.fillRect(0, 0, fruitOrderCanvas.width, fruitOrderCanvas.height);

            for (let i = 0; i < 8; i++) {
                const radius = Math.min(baseRadius * relativeRadii[i], maxSize / 2);
                if (useImages && allImagesLoaded) {
                    const size = radius * 2;
                    fruitCtx.drawImage(
                        fruitImages[i],
                        padding + slotSize * i + slotSize / 2 - radius,
                        padding + slotSize / 2 - radius,
                        size,
                        size
                    );
                } else {
                    const fruit = new Fruit(0, 0, i);
                    fruit.radius = radius;
                    fruit.scale = 1;
                    fruitCtx.save();
                    fruitCtx.translate(padding + slotSize * i + slotSize / 2, padding + slotSize / 2);
                    fruit.draw(fruitCtx);
                    fruitCtx.restore();
                }
            }

            fruitOrderDisplay.innerHTML = '';
            fruitOrderDisplay.appendChild(fruitOrderCanvas);
        }
        drawFruitOrder();

        function spawnFruit() {
            if (gameOver || !gameStarted) return;
            const randomOffset = (Math.random() - 0.5) * 4;
            let spawnX = Math.max(nextFruit.radius, Math.min(canvas.width - nextFruit.radius, aimingX + randomOffset));
            let newFruit = new Fruit(spawnX, 50, nextFruit.type);
            fruits.push(newFruit);
            nextFruit = new Fruit(aimingX, 50, Math.floor(Math.random() * 3));
            lastSpawnTime = Date.now();
            score--;
            scoreDisplay.textContent = `Puntaje: ${score}`;
            scoreDisplay.classList.remove('pulse');
        }

        function drawDashedLine() {
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#666';
            ctx.beginPath();
            ctx.moveTo(aimingX, 0);
            ctx.lineTo(aimingX, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function triggerLiquidExplosion(x, y, amount = 20, fruitType) {
            const colorSets = [
                ['#1E90FF', '#87CEEB', '#ADD8E6'],
                ['#90EE90', '#98FB98', '#32CD32'],
                ['#FF4040', '#FF6347', '#DC143C'],
                ['#800080', '#9932CC', '#BA55D3'],
                ['#FFA500', '#FFD700', '#FF8C00'],
                ['#FF1493', '#FF69B4', '#C71585'],
                ['#98FB98', '#00FF7F', '#ADFF2F'],
                ['#FF4500', '#FF6347', '#FF0000']
            ];
            const colors = colorSets[fruitType];
            for (let j = 0; j < amount; j++) {
                liquidDrops.push(new LiquidDrop(x, y, colors[Math.floor(Math.random() * colors.length)]));
            }
        }

        function assignRandomTrick(fruit) {
            if (fruit.type >= 5 && Math.random() < TRICK_PROBABILITY) { // Solo tipos 5, 6 y 7
                fruit.hasTrick = Math.floor(Math.random() * 3) + 1; // 1, 2 o 3
            }
        }

        function applyTrick(fruit) {
            switch (fruit.hasTrick) {
                case 1: // -5s
                    gameTime = Math.max(0, gameTime - 5);
                    timerDisplay.textContent = `Tiempo: ${gameTime}s`;
                    timerDisplay.classList.add('pulseGreen');
                    setTimeout(() => timerDisplay.classList.remove('pulseGreen'), 500);
                    bonusTexts.push(new BonusText(fruit.x, fruit.y, "-5s"));
                    break;
                case 2: // ‚ù§Ô∏è
                    if (lives < MAX_LIVES) {
                        lives++;
                        updateLivesDisplay();
                        livesDisplay.classList.add('lifeLost');
                        setTimeout(() => livesDisplay.classList.remove('lifeLost'), 500);
                        bonusTexts.push(new BonusText(fruit.x, fruit.y, "+1 vida"));
                    }
                    break;
                case 3: // üçâ
                    nextFruit = new Fruit(aimingX, 50, 7); // Sand√≠a
                    nextFruit.scale = 1;
                    ctx.save();
                    ctx.translate(nextFruit.x, nextFruit.y);
                    ctx.scale(1.2, 1.2);
                    nextFruit.draw();
                    ctx.restore();
                    setTimeout(() => nextFruit.scale = 1, 500);
                    bonusTexts.push(new BonusText(fruit.x, fruit.y, "¬°Sand√≠a!"));
                    break;
            }
            triggerLiquidExplosion(fruit.x, fruit.y, 15, fruit.type);
            fruits.splice(fruits.indexOf(fruit), 1);
        }

        function checkCollisions() {
            if (gameOver || !gameStarted) return;
            for (let i = 0; i < fruits.length; i++) {
                for (let j = i + 1; j < fruits.length; j++) {
                    let f1 = fruits[i];
                    let f2 = fruits[j];
                    let dx = f2.x - f1.x;
                    let dy = f2.y - f1.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    let minDistance = f1.radius * f1.scale + f2.radius * f2.scale;

                    if (distance < minDistance && f1.scale >= 0.9 && f2.scale >= 0.9) {
                        const timeSincePerturbed1 = Date.now() - f1.lastPerturbedTime;
                        const timeSincePerturbed2 = Date.now() - f2.lastPerturbedTime;

                        if (f1.isFrozen && f2.isFrozen && timeSincePerturbed1 > 3000 && timeSincePerturbed2 > 3000) continue;

                        if (!f1.isFrozen) f1.lastPerturbedTime = Date.now();
                        if (!f2.isFrozen) f2.lastPerturbedTime = Date.now();
                        f1.isFrozen = false;
                        f2.isFrozen = false;

                        if (f1.type === f2.type && !f1.isMerging && !f2.isMerging) {
                            f1.isMerging = true;
                            f2.isMerging = true;
                            f1.shrinkSpeed = 0.1;
                            f2.shrinkSpeed = 0.1;
                            if (f1.type === 7) {
                                setTimeout(() => {
                                    const index1 = fruits.indexOf(f1);
                                    const index2 = fruits.indexOf(f2);
                                    if (index1 !== -1 && index2 !== -1) {
                                        fruits.splice(index1, 1);
                                        fruits.splice(index2 > index1 ? index2 - 1 : index2, 1);
                                        if (lives < MAX_LIVES) {
                                            lives++;
                                            updateLivesDisplay();
                                        }
                                        triggerLiquidExplosion(f1.x, f1.y, 40, 7);
                                        setTimeout(() => triggerLiquidExplosion(f1.x, f1.y, 40, 7), 200);
                                        setTimeout(() => triggerLiquidExplosion(f1.x, f1.y, 40, 7), 400);
                                        score += 3;
                                        bonusTexts.push(new BonusText(f1.x, f1.y, "+3"));
                                        scoreDisplay.textContent = `Puntaje: ${score}`;
                                        scoreDisplay.classList.add('scoreAdd');
                                        setTimeout(() => scoreDisplay.classList.remove('scoreAdd'), 500);
                                    }
                                }, 100);
                            } else {
                                let newType = f1.type + 1;
                                let newX = (f1.x + f2.x) / 2;
                                let newY = (f1.y + f2.y) / 2;
                                setTimeout(() => {
                                    const index1 = fruits.indexOf(f1);
                                    const index2 = fruits.indexOf(f2);
                                    if (index1 !== -1 && index2 !== -1) {
                                        fruits.splice(index1, 1);
                                        fruits.splice(index2 > index1 ? index2 - 1 : index2, 1);
                                        let newFruit = new Fruit(newX, newY, newType, 0);
                                        newFruit.growSpeed = 0.1;
                                        newFruit.angularVelocity = (Math.random() - 0.5) * 0.1;
                                        assignRandomTrick(newFruit); // Asignar truco aqu√≠
                                        fruits.push(newFruit);
                                        triggerLiquidExplosion(newX, newY, 20, f1.type);
                                        if (newType === 5) {
                                            score += 1;
                                            bonusTexts.push(new BonusText(newX, newY, "+1"));
                                            scoreDisplay.classList.add('scoreAdd');
                                            setTimeout(() => scoreDisplay.classList.remove('scoreAdd'), 500);
                                        } else if (newType === 6) {
                                            score += 2;
                                            bonusTexts.push(new BonusText(newX, newY, "+2"));
                                            scoreDisplay.classList.add('scoreAdd');
                                            setTimeout(() => scoreDisplay.classList.remove('scoreAdd'), 500);
                                        }
                                        scoreDisplay.textContent = `Puntaje: ${score}`;
                                    }
                                }, 100);
                            }
                        } else {
                            let nx = dx / distance || 0;
                            let ny = dy / distance || 0;
                            let overlap = minDistance - distance;

                            let totalMass = f1.mass + f2.mass;
                            let correction1 = overlap * f2.mass / totalMass;
                            let correction2 = overlap * f1.mass / totalMass;

                            f1.x -= nx * correction1;
                            f1.y -= ny * correction1;
                            f1.vx *= 0.8;
                            f1.vy *= 0.8;
                            f1.angularVelocity += (f2.vx - f1.vx) * 0.02 / f1.mass;

                            f2.x += nx * correction2;
                            f2.y += ny * correction2;
                            f2.vx *= 0.8;
                            f2.vy *= 0.8;
                            f2.angularVelocity -= (f1.vx - f2.vx) * 0.02 / f2.mass;

                            f1.x = Math.max(f1.radius * f1.scale, Math.min(canvas.width - f1.radius * f1.scale, f1.x));
                            f1.y = Math.max(f1.radius * f1.scale, Math.min(canvas.height - f1.radius * f1.scale, f1.y));
                            f2.x = Math.max(f2.radius * f2.scale, Math.min(canvas.width - f2.radius * f2.scale, f2.x));
                            f2.y = Math.max(f2.radius * f2.scale, Math.min(canvas.height - f2.radius * f2.scale, f2.y));
                        }
                    }
                }
            }
        }

        function updateLivesDisplay() {
            let hearts = '';
            for (let i = 0; i < MAX_LIVES; i++) {
                hearts += i < lives ? '‚ù§Ô∏è' : 'üñ§';
            }
            livesDisplay.textContent = hearts;
        }

        function updateTimer() {
            if (gameOver || !gameStarted) return;
            const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
            gameTime = GAME_DURATION - elapsed;
            timerDisplay.textContent = `Tiempo: ${gameTime}s`;
            if (gameTime <= 60) {
                timerDisplay.classList.add('pulseGreen');
            } else {
                timerDisplay.classList.remove('pulseGreen');
            }
            if (gameTime <= 0) {
                endGame(true);
            }
        }

        function decreaseScore() {
            if (gameOver || !gameStarted) return;
            const timeSinceLastSpawn = Date.now() - lastSpawnTime;
            if (timeSinceLastSpawn >= INACTIVITY_THRESHOLD) {
                score -= 5;
                scoreDisplay.classList.add('pulse');
            } else {
                scoreDisplay.classList.remove('pulse');
            }
            scoreDisplay.textContent = `Puntaje: ${score}`;
            if (score <= 0 && lives > 0) {
                scoreDisplay.classList.add('scoreZero');
                livesDisplay.classList.add('lifeLost');
                setTimeout(() => {
                    scoreDisplay.classList.remove('scoreZero');
                    livesDisplay.classList.remove('lifeLost');
                    lives--;
                    updateLivesDisplay();
                    score = INITIAL_SCORE;
                    scoreDisplay.textContent = `Puntaje: ${score}`;
                    if (lives === 0) {
                        endGame(false);
                    }
                }, 500);
            }
        }

        function endGame(won) {
            gameOver = true;
            gameOverDisplay.style.display = 'block';
            if (won) {
                gameResultDisplay.textContent = '¬°Ganaste!';
                finalScoreDisplay.textContent = lives * score;
            } else {
                gameResultDisplay.textContent = 'Perdiste';
                finalScoreDisplay.textContent = 0;
            }
        }

        function startGame() {
            gameStarted = true;
            gameStartTime = Date.now();
            lastSpawnTime = Date.now();
            startScreen.style.display = 'none';
            setInterval(updateTimer, 1000);
            setInterval(decreaseScore, 1000);
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            fruits.forEach(fruit => {
                fruit.update();
                if (fruit.scale > 0) fruit.draw();
            });

            liquidDrops.forEach((drop, i) => {
                drop.update();
                drop.draw();
                if (drop.life <= 0) liquidDrops.splice(i, 1);
            });

            bonusTexts.forEach((text, i) => {
                text.update();
                text.draw();
                if (text.life <= 0) bonusTexts.splice(i, 1);
            });

            if (isAiming && !gameOver && gameStarted) drawDashedLine();
            if (!gameOver && gameStarted) {
                nextFruit.x = aimingX;
                nextFruit.draw();
            }

            checkCollisions();

            requestAnimationFrame(gameLoop);
        }

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameOver && gameStarted) {
                const touchX = e.touches[0].clientX - canvas.offsetLeft;
                const touchY = e.touches[0].clientY - canvas.offsetTop;
                const fruit = fruits.find(f => 
                    f.hasTrick > 0 &&
                    Math.sqrt((f.x - touchX) ** 2 + (f.y - touchY) ** 2) < f.radius * f.scale
                );
                if (fruit) {
                    applyTrick(fruit);
                } else {
                    isAiming = true;
                    aimingX = Math.max(nextFruit.radius, Math.min(canvas.width - nextFruit.radius, touchX));
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isAiming && !gameOver && gameStarted) {
                aimingX = Math.max(nextFruit.radius, Math.min(canvas.width - nextFruit.radius, e.touches[0].clientX - canvas.offsetLeft));
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (isAiming && !gameOver && gameStarted) {
                spawnFruit();
                isAiming = false;
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (!gameOver && gameStarted) {
                const clickX = e.clientX - canvas.offsetLeft;
                const clickY = e.clientY - canvas.offsetTop;
                const fruit = fruits.find(f => 
                    f.hasTrick > 0 &&
                    Math.sqrt((f.x - clickX) ** 2 + (f.y - clickY) ** 2) < f.radius * f.scale
                );
                if (fruit) {
                    applyTrick(fruit);
                } else {
                    isAiming = true;
                    aimingX = Math.max(nextFruit.radius, Math.min(canvas.width - nextFruit.radius, clickX));
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            e.preventDefault();
            if (isAiming && !gameOver && gameStarted) {
                aimingX = Math.max(nextFruit.radius, Math.min(canvas.width - nextFruit.radius, e.clientX - canvas.offsetLeft));
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            if (isAiming && !gameOver && gameStarted) {
                spawnFruit();
                isAiming = false;
            }
        });

        startButton.addEventListener('click', startGame);

        gameLoop();

        function toggleRenderMode() {
            useImages = !useImages;
            console.log(`Modo de renderizado cambiado a: ${useImages ? 'Im√°genes' : 'Dibujos'}`);
            drawFruitOrder();
        }
    </script>
</body>
</html>