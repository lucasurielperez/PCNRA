<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Objetos Espaciales con Peso</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #0A0A23;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #FFFFFF;
            background-color: #1C2526;
            touch-action: none;
        }
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #FFFFFF;
            font-size: 20px;
            font-weight: bold;
        }
        #lives {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
        }
        #spaceOrder {
            position: absolute;
            top: 40px;
            left: 10px;
            display: flex;
            gap: 2px;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            font-size: 24px;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Puntaje: 50</div>
    <div id="lives">❤️❤️❤️</div>
    <div id="spaceOrder"></div>
    <div id="gameOver">Fin!<br>Hiciste <span id="finalScore">0</span> puntos.</div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const spaceOrderDisplay = document.getElementById('spaceOrder');
        const gameOverDisplay = document.getElementById('gameOver');
        const finalScoreDisplay = document.getElementById('finalScore');

        canvas.width = Math.min(window.innerWidth * 0.9, 400);
        canvas.height = Math.min(window.innerHeight * 0.9, 600) - 50;

        const GRAVITY = 0.98;
        const TERMINAL_VELOCITY = 20;
        const BASE_BOUNCE_WALL = 0.7;
        const BASE_BOUNCE_FLOOR = 0.6;
        const BASE_FRICTION = 0.92;
        const FINAL_FRICTION = 0.3;
        const ROTATION_FRICTION = 0.95;
        const MAX_ANGULAR_VELOCITY = 2 * Math.PI / 60;
        const FREEZE_DELAY = 3000;
        const FREEZE_DURATION = 1000;
        const MAX_COLLISION_VELOCITY = 10;
        const ROT_TIME = 60 * 1000;
        const STONE_FRICTION = 0.85;
        const INITIAL_SCORE = 50;
        const STONE_MASS_MULTIPLIER = 1000;

        let score = INITIAL_SCORE;
        let lives = 3;
        let totalScore = 0;
        let lastSpawnTime = Date.now();
        let gameOver = false;

        class SpaceObject {
            constructor(x, y, type, scale = 1) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = [8, 10, 15, 24, 33, 42, 51, 60, 70][type] * 1.44;
                this.mass = [0.5, 1, 2, 4, 8, 16, 32, 64, 128][type];
                this.originalMass = this.mass;
                this.vx = 0;
                this.vy = 0;
                this.scale = scale;
                this.shrinkSpeed = 0;
                this.growSpeed = 0;
                this.angle = 0;
                this.angularVelocity = (Math.random() - 0.5) * 0.15;
                this.isFrozen = false;
                this.isMerging = false;
                this.lastPerturbedTime = Date.now();
                this.initialEnergy = GRAVITY * canvas.height;
                this.creationTime = Date.now();
                this.rotProgress = 0;
                this.isRotten = false;
            }

            draw(context = ctx) {
                context.save();
                context.translate(this.x, this.y);
                context.scale(this.scale, this.scale);
                context.rotate(this.angle);

                const rotFactor = this.rotProgress;
                if (rotFactor >= 1) {
                    context.fillStyle = '#333333'; // Gris oscuro para objetos "podridos"
                    context.beginPath();
                    context.arc(0, 0, this.radius, 0, Math.PI * 2);
                    context.fill();
                } else {
                    const baseColors = [
                        '#808080', '#C0C0C0', '#00CED1', '#FF4500',
                        '#FFD700', '#8A2BE2', '#00FF7F', '#000000',
                        '#FF00FF'
                    ];
                    const baseColor = baseColors[this.type];
                    const r = parseInt(baseColor.slice(1, 3), 16) * (1 - rotFactor);
                    const g = parseInt(baseColor.slice(3, 5), 16) * (1 - rotFactor);
                    const b = parseInt(baseColor.slice(5, 7), 16) * (1 - rotFactor);
                    context.fillStyle = `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;

                    context.beginPath();
                    context.arc(0, 0, this.radius, 0, Math.PI * 2);
                    context.fill();

                    if (this.type === 0) { // Asteroide
                        context.fillStyle = `rgba(128, 128, 128, ${0.5 * (1 - rotFactor)})`;
                        context.beginPath();
                        context.arc(3, -3, 2, 0, Math.PI * 2);
                        context.arc(-2, 2, 1.5, 0, Math.PI * 2);
                        context.fill();
                    } else if (this.type === 1) { // Luna
                        context.fillStyle = `rgba(169, 169, 169, ${0.7 * (1 - rotFactor)})`;
                        context.beginPath();
                        context.arc(4, -4, 3, 0, Math.PI * 2);
                        context.arc(-3, 3, 2, 0, Math.PI * 2);
                        context.fill();
                    } else if (this.type === 2) { // Planeta Tierra
                        context.fillStyle = `rgba(0, 191, 255, ${1 - rotFactor})`;
                        context.beginPath();
                        context.arc(0, 0, this.radius - 5, 0, Math.PI * 2);
                        context.fill();
                        context.fillStyle = `rgba(34, 139, 34, ${1 - rotFactor})`;
                        context.beginPath();
                        context.arc(5, -5, 3, 0, Math.PI * 2);
                        context.fill();
                    } else if (this.type === 3) { // Júpiter
                        context.fillStyle = `rgba(210, 105, 30, ${1 - rotFactor})`;
                        context.beginPath();
                        context.arc(0, 0, this.radius - 5, 0, Math.PI * 2);
                        context.fill();
                        context.strokeStyle = `rgba(255, 165, 0, ${1 - rotFactor})`;
                        context.lineWidth = 2;
                        context.beginPath();
                        context.moveTo(-this.radius + 5, 0);
                        context.lineTo(this.radius - 5, 0);
                        context.stroke();
                    } else if (this.type === 4) { // Sistema Solar
                        context.fillStyle = `rgba(255, 215, 0, ${0.8 * (1 - rotFactor)})`;
                        context.beginPath();
                        context.arc(0, 0, this.radius - 10, 0, Math.PI * 2);
                        context.fill();
                        context.strokeStyle = `rgba(255, 255, 255, ${0.5 * (1 - rotFactor)})`;
                        context.lineWidth = 1;
                        for (let i = 0; i < 3; i++) {
                            context.beginPath();
                            context.arc(0, 0, this.radius - 15 - i * 5, 0, Math.PI * 2);
                            context.stroke();
                        }
                    } else if (this.type === 5) { // Galaxia
                        context.fillStyle = `rgba(138, 43, 226, ${1 - rotFactor})`;
                        for (let i = 0; i < 4; i++) {
                            let angle = (Math.PI * 2 / 4) * i;
                            context.beginPath();
                            context.moveTo(0, 0);
                            context.lineTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                            context.strokeStyle = `rgba(147, 112, 219, ${1 - rotFactor})`;
                            context.lineWidth = 3;
                            context.stroke();
                        }
                    } else if (this.type === 6) { // Cúmulo
                        context.fillStyle = `rgba(0, 255, 127, ${1 - rotFactor})`;
                        for (let i = 0; i < 5; i++) {
                            let angle = (Math.PI * 2 / 5) * i;
                            context.beginPath();
                            context.arc(Math.cos(angle) * (this.radius - 10), Math.sin(angle) * (this.radius - 10), 5, 0, Math.PI * 2);
                            context.fill();
                        }
                    } else if (this.type === 7) { // Agujero Negro
                        context.fillStyle = `rgba(0, 0, 0, ${1 - rotFactor})`;
                        context.beginPath();
                        context.arc(0, 0, this.radius - 5, 0, Math.PI * 2);
                        context.fill();
                        context.strokeStyle = `rgba(255, 255, 255, ${0.5 * (1 - rotFactor)})`;
                        context.lineWidth = 3;
                        context.beginPath();
                        context.arc(0, 0, this.radius, 0, Math.PI * 2);
                        context.stroke();
                    } else { // Supernova
                        context.fillStyle = `rgba(255, 0, 255, ${1 - rotFactor})`;
                        context.beginPath();
                        context.arc(0, 0, this.radius - 5, 0, Math.PI * 2);
                        context.fill();
                        context.strokeStyle = `rgba(255, 255, 0, ${1 - rotFactor})`;
                        context.lineWidth = 2;
                        for (let i = 0; i < 6; i++) {
                            let angle = (Math.PI * 2 / 6) * i;
                            context.beginPath();
                            context.moveTo(0, 0);
                            context.lineTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                            context.stroke();
                        }
                    }
                }
                context.restore();
            }

            update() {
                if (gameOver || this.isFrozen) {
                    this.angularVelocity = 0;
                    this.vx = 0;
                    this.vy = 0;
                    return;
                }

                const timeElapsed = Date.now() - this.creationTime;
                this.rotProgress = Math.min(timeElapsed / ROT_TIME, 1);
                if (this.rotProgress >= 1 && !this.isRotten) {
                    this.isRotten = true;
                    this.mass = this.originalMass * STONE_MASS_MULTIPLIER;
                    this.vx = 0;
                    this.vy = 0;
                    this.angularVelocity = 0;
                    this.isFrozen = true;
                }

                if (this.isRotten) {
                    this.vx = 0;
                    this.vy = 0;
                    this.angularVelocity = 0;
                    return;
                }

                if (this.x - this.radius * this.scale < 0) {
                    this.x = this.radius * this.scale;
                }
                if (this.x + this.radius * this.scale > canvas.width) {
                    this.x = canvas.width - this.radius * this.scale;
                }
                if (this.y - this.radius * this.scale < 0) {
                    this.y = this.radius * this.scale;
                }
                if (this.y + this.radius * this.scale > canvas.height) {
                    this.y = canvas.height - this.radius * this.scale;
                }

                this.vy = Math.min(this.vy + GRAVITY, TERMINAL_VELOCITY);
                this.x += this.vx;
                this.y += this.vy;

                const timeSinceLastPerturbed = Date.now() - this.lastPerturbedTime;
                let friction;
                if (timeSinceLastPerturbed > FREEZE_DELAY + FREEZE_DURATION) {
                    this.isFrozen = true;
                    this.vx = 0;
                    this.vy = 0;
                    this.angularVelocity = 0;
                    return;
                } else if (timeSinceLastPerturbed > FREEZE_DELAY) {
                    const progress = (timeSinceLastPerturbed - FREEZE_DELAY) / FREEZE_DURATION;
                    friction = BASE_FRICTION - (BASE_FRICTION - FINAL_FRICTION) * progress;
                } else {
                    friction = BASE_FRICTION - (this.mass / 128) * 0.1;
                }

                this.vx *= friction;
                this.vy *= friction;

                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 0.1 || Math.abs(this.angularVelocity) > 0.01) {
                    this.angle += this.angularVelocity;
                    this.angularVelocity = Math.max(-MAX_ANGULAR_VELOCITY, Math.min(MAX_ANGULAR_VELOCITY, this.angularVelocity));
                    this.angularVelocity *= friction;
                } else {
                    this.angularVelocity = 0;
                }

                const bounceFloor = BASE_BOUNCE_FLOOR * (1 - this.mass / 128 * 0.5);
                const bounceWall = BASE_BOUNCE_WALL * (1 - this.mass / 128 * 0.5);

                if (this.x - this.radius * this.scale < 0) {
                    this.x = this.radius * this.scale;
                    this.vx = Math.min(Math.abs(this.vx) * bounceWall, Math.sqrt(this.initialEnergy));
                } else if (this.x + this.radius * this.scale > canvas.width) {
                    this.x = canvas.width - this.radius * this.scale;
                    this.vx = -Math.min(Math.abs(this.vx) * bounceWall, Math.sqrt(this.initialEnergy));
                }
                if (this.y + this.radius * this.scale > canvas.height) {
                    this.y = canvas.height - this.radius * this.scale;
                    this.vy = -Math.min(Math.abs(this.vy) * bounceFloor, Math.sqrt(this.initialEnergy));
                    if (Math.abs(this.vy) < 0.5) this.vy = 0;
                }
                if (this.y - this.radius * this.scale < 0) {
                    this.y = this.radius * this.scale;
                    this.vy = Math.min(Math.abs(this.vy) * bounceFloor, Math.sqrt(this.initialEnergy));
                    if (lives > 0) {
                        lives--;
                        livesDisplay.textContent = '❤️'.repeat(lives);
                        if (lives === 0) {
                            gameOver = true;
                            gameOverDisplay.style.display = 'block';
                            finalScoreDisplay.textContent = totalScore;
                        }
                    }
                }

                this.x = Math.max(this.radius * this.scale, Math.min(canvas.width - this.radius * this.scale, this.x));
                this.y = Math.max(this.radius * this.scale, Math.min(canvas.height - this.radius * this.scale, this.y));

                if (this.shrinkSpeed > 0) {
                    this.scale -= this.shrinkSpeed;
                    if (this.scale <= 0) this.scale = 0;
                }
                if (this.growSpeed > 0) {
                    this.scale += this.growSpeed;
                    if (this.scale >= 1) this.scale = 1;
                }
            }
        }

        class Confetti {
            constructor(x, y, color, size = 4) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 60;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1;
                this.life--;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        let spaceObjects = [];
        let confetti = [];
        let nextObject = new SpaceObject(canvas.width / 2, 50, Math.floor(Math.random() * 3));
        let aimingX = canvas.width / 2;
        let isAiming = false;

        function drawSpaceOrder() {
            const spaceOrderCanvas = document.createElement('canvas');
            const spaceCtx = spaceOrderCanvas.getContext('2d');
            const maxSize = 24;
            const baseRadius = 10;
            const relativeRadii = [0.5, 0.625, 1, 1.5, 2, 2.5, 3, 3.5, 4];
            const slotSize = maxSize;
            const padding = 2;

            spaceOrderCanvas.width = slotSize * 9 + padding * 2;
            spaceOrderCanvas.height = slotSize + padding * 2;
            spaceCtx.fillStyle = '#0A0A23';
            spaceCtx.fillRect(0, 0, spaceOrderCanvas.width, spaceOrderCanvas.height);

            for (let i = 0; i < 9; i++) {
                const radius = Math.min(baseRadius * relativeRadii[i], maxSize / 2);
                const spaceObj = new SpaceObject(0, 0, i);
                spaceObj.radius = radius;
                spaceObj.scale = 1;
                spaceCtx.save();
                spaceCtx.translate(padding + slotSize * i + slotSize / 2, padding + slotSize / 2);
                spaceObj.draw(spaceCtx);
                spaceCtx.restore();
            }

            spaceOrderDisplay.innerHTML = '';
            spaceOrderDisplay.appendChild(spaceOrderCanvas);
        }
        drawSpaceOrder();

        function spawnSpaceObject() {
            if (gameOver) return;
            let newObject = new SpaceObject(aimingX, 50, nextObject.type);
            spaceObjects.push(newObject);
            nextObject = new SpaceObject(aimingX, 50, Math.floor(Math.random() * 3));
            lastSpawnTime = Date.now();
            score--;
            if (score <= 0 && lives > 0) {
                lives--;
                livesDisplay.textContent = '❤️'.repeat(lives);
                score = INITIAL_SCORE;
            }
            scoreDisplay.textContent = `Puntaje: ${score}`;
            if (lives === 0) {
                gameOver = true;
                gameOverDisplay.style.display = 'block';
                finalScoreDisplay.textContent = totalScore;
            }
        }

        function drawDashedLine() {
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.moveTo(aimingX, 0);
            ctx.lineTo(aimingX, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function triggerConfettiExplosion(x, y, amount = 20, spaceType) {
            const colorSets = [
                ['#808080', '#A9A9A9', '#696969'], // Asteroide
                ['#C0C0C0', '#D3D3D3', '#FFFFFF'], // Luna
                ['#00CED1', '#228B22', '#000080'], // Tierra
                ['#FF4500', '#D2691E', '#FFA500'], // Júpiter
                ['#FFD700', '#FFFFFF', '#FF8C00'], // Sistema Solar
                ['#8A2BE2', '#9370DB', '#4B0082'], // Galaxia
                ['#00FF7F', '#98FB98', '#00CED1'], // Cúmulo
                ['#000000', '#FFFFFF', '#696969'], // Agujero Negro
                ['#FF00FF', '#FFFF00', '#FF69B4']  // Supernova
            ];
            const colors = colorSets[spaceType];
            for (let j = 0; j < amount; j++) {
                confetti.push(new Confetti(x, y, colors[Math.floor(Math.random() * colors.length)]));
            }
        }

        function checkCollisions() {
            if (gameOver) return;
            for (let i = 0; i < spaceObjects.length; i++) {
                for (let j = i + 1; j < spaceObjects.length; j++) {
                    let s1 = spaceObjects[i];
                    let s2 = spaceObjects[j];
                    let dx = s2.x - s1.x;
                    let dy = s2.y - s1.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    let minDistance = s1.radius * s1.scale + s2.radius * s2.scale;

                    if (distance < minDistance && s1.scale >= 0.9 && s2.scale >= 0.9) {
                        const timeSincePerturbed1 = Date.now() - s1.lastPerturbedTime;
                        const timeSincePerturbed2 = Date.now() - s2.lastPerturbedTime;

                        if (s1.isFrozen && s2.isFrozen && timeSincePerturbed1 > 3000 && timeSincePerturbed2 > 3000) continue;

                        if (!s1.isFrozen) s1.lastPerturbedTime = Date.now();
                        if (!s2.isFrozen) s2.lastPerturbedTime = Date.now();
                        s1.isFrozen = false;
                        s2.isFrozen = false;

                        if (s1.type === s2.type && !s1.isMerging && !s2.isMerging && !s1.isRotten && !s2.isRotten) {
                            s1.isMerging = true;
                            s2.isMerging = true;
                            s1.shrinkSpeed = 0.1;
                            s2.shrinkSpeed = 0.1;
                            if (s1.type === 8) { // Supernova
                                setTimeout(() => {
                                    const index1 = spaceObjects.indexOf(s1);
                                    const index2 = spaceObjects.indexOf(s2);
                                    if (index1 !== -1 && index2 !== -1) {
                                        spaceObjects.splice(index1, 1);
                                        spaceObjects.splice(index2 > index1 ? index2 - 1 : index2, 1);
                                        score += 300;
                                        totalScore += 300;
                                        scoreDisplay.textContent = `Puntaje: ${score}`;
                                        triggerConfettiExplosion(s1.x, s1.y, 40, 8);
                                        setTimeout(() => triggerConfettiExplosion(s1.x, s1.y, 40, 8), 200);
                                        setTimeout(() => triggerConfettiExplosion(s1.x, s1.y, 40, 8), 400);
                                    }
                                }, 100);
                            } else {
                                let newType = s1.type + 1;
                                let newX = (s1.x + s2.x) / 2;
                                let newY = (s1.y + s2.y) / 2;
                                setTimeout(() => {
                                    const index1 = spaceObjects.indexOf(s1);
                                    const index2 = spaceObjects.indexOf(s2);
                                    if (index1 !== -1 && index2 !== -1) {
                                        spaceObjects.splice(index1, 1);
                                        spaceObjects.splice(index2 > index1 ? index2 - 1 : index2, 1);
                                        let newObject = new SpaceObject(newX, newY, newType, 0);
                                        newObject.growSpeed = 0.1;
                                        newObject.angularVelocity = (Math.random() - 0.5) * 0.1;
                                        spaceObjects.push(newObject);
                                        triggerConfettiExplosion(newX, newY, 20, s1.type);
                                    }
                                }, 100);
                            }
                        } else if (s1.isMerging || s2.isMerging) {
                            let nx = dx / distance || 0;
                            let ny = dy / distance || 0;
                            let overlap = minDistance - distance;
                            let correction = overlap / 2;
                            if (!s1.isFrozen) {
                                s1.x -= nx * correction;
                                s1.y -= ny * correction;
                            }
                            if (!s2.isFrozen) {
                                s2.x += nx * correction;
                                s2.y += ny * correction;
                            }
                        } else if (!s1.isFrozen || !s2.isFrozen) {
                            let nx = dx / distance || 0;
                            let ny = dy / distance || 0;

                            let overlap = minDistance - distance;
                            let correction = overlap / 2;

                            if (s1.isRotten && !s2.isRotten) {
                                s2.x += nx * overlap;
                                s2.y += ny * overlap;
                            } else if (s2.isRotten && !s1.isRotten) {
                                s1.x -= nx * overlap;
                                s1.y -= ny * overlap;
                            } else {
                                if (!s1.isFrozen) {
                                    s1.x -= nx * correction;
                                    s1.y -= ny * correction;
                                }
                                if (!s2.isFrozen) {
                                    s2.x += nx * correction;
                                    s2.y += ny * correction;
                                }
                            }

                            if (s1.isRotten || s2.isRotten) {
                                let movingObject = s1.isRotten ? s2 : s1;
                                let rock = s1.isRotten ? s1 : s2;

                                let vRelativeX = movingObject.vx;
                                let vRelativeY = movingObject.vy;
                                let speed = Math.sqrt(vRelativeX * vRelativeX + vRelativeY * vRelativeY);
                                let impulse = speed * movingObject.mass;

                                movingObject.vx = -vRelativeX * 0.7;
                                movingObject.vy = -vRelativeY * 0.7;
                            } else {
                                let fallingObject = s1.vy > s2.vy ? s1 : s2;
                                let restingObject = s1.vy > s2.vy ? s2 : s1;

                                let v1n = fallingObject.vx * nx + fallingObject.vy * ny;
                                let v2n = restingObject.vx * nx + restingObject.vy * ny;

                                let v1t = fallingObject.vx - v1n * nx;
                                let v2t = restingObject.vx - v2n * nx;

                                let totalMass = fallingObject.mass + restingObject.mass;

                                let finalV1n = ((fallingObject.mass - restingObject.mass) * v1n + 2 * restingObject.mass * v2n) / totalMass;
                                let finalV2n = ((restingObject.mass - fallingObject.mass) * v2n + 2 * fallingObject.mass * v1n) / totalMass;

                                const bounceFactor = 0.3 * (1 - (fallingObject.mass + restingObject.mass) / 256 * 0.5);
                                const energyLoss = 0.7;
                                finalV1n *= bounceFactor * energyLoss;
                                finalV2n *= bounceFactor * energyLoss;

                                const maxSpeed = Math.sqrt(fallingObject.initialEnergy);
                                finalV1n = Math.max(-maxSpeed, Math.min(maxSpeed, finalV1n));
                                finalV2n = Math.max(-maxSpeed, Math.min(maxSpeed, finalV2n));

                                if (fallingObject.mass < restingObject.mass) {
                                    finalV2n = Math.max(finalV2n, 0);
                                    finalV1n *= Math.min(1, restingObject.mass / fallingObject.mass * 0.5);
                                } else {
                                    finalV2n *= Math.min(1, fallingObject.mass / restingObject.mass * 0.5);
                                }

                                if (!fallingObject.isFrozen) {
                                    fallingObject.vx = v1t + finalV1n * nx;
                                    fallingObject.vy = finalV1n * ny;
                                    fallingObject.vx = Math.max(-maxSpeed, Math.min(maxSpeed, fallingObject.vx));
                                    fallingObject.vy = Math.max(-maxSpeed, Math.min(maxSpeed, fallingObject.vy));
                                }
                                if (!restingObject.isFrozen) {
                                    restingObject.vx = v2t + finalV2n * nx;
                                    restingObject.vy = finalV2n * ny;
                                    restingObject.vx = Math.max(-maxSpeed, Math.min(maxSpeed, restingObject.vx));
                                    restingObject.vy = Math.max(-maxSpeed, Math.min(maxSpeed, restingObject.vy));
                                }

                                let relativeVelocityX = s2.vx - s1.vx;
                                let relativeVelocityY = s2.vy - s1.vy;
                                let angularImpulse = (relativeVelocityX * dy - relativeVelocityY * dx) / (s1.radius + s2.radius);
                                if (!s1.isFrozen) s1.angularVelocity = Math.min(0.01, (angularImpulse / s1.radius * 0.005) / s1.mass);
                                if (!s2.isFrozen) s2.angularVelocity = Math.min(0.01, (angularImpulse / s2.radius * 0.005) / s2.mass);
                            }

                            if (!s1.isFrozen && Math.abs(s1.vx) < 0.1) s1.vx = 0;
                            if (!s1.isFrozen && Math.abs(s1.vy) < 0.1) s1.vy = 0;
                            if (!s2.isFrozen && Math.abs(s2.vx) < 0.1) s2.vx = 0;
                            if (!s2.isFrozen && Math.abs(s2.vy) < 0.1) s2.vy = 0;
                        }
                    }
                }
            }
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            spaceObjects.forEach(obj => {
                obj.update();
                if (obj.scale > 0) obj.draw();
            });

            confetti.forEach((c, i) => {
                c.update();
                c.draw();
                if (c.life <= 0) confetti.splice(i, 1);
            });

            if (isAiming && !gameOver) drawDashedLine();
            if (!gameOver) {
                nextObject.x = aimingX;
                nextObject.draw();
            }

            checkCollisions();

            requestAnimationFrame(gameLoop);
        }

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameOver) isAiming = true;
            aimingX = Math.max(nextObject.radius, Math.min(canvas.width - nextObject.radius, e.touches[0].clientX - canvas.offsetLeft));
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isAiming && !gameOver) {
                aimingX = Math.max(nextObject.radius, Math.min(canvas.width - nextObject.radius, e.touches[0].clientX - canvas.offsetLeft));
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (isAiming && !gameOver) {
                spawnSpaceObject();
                isAiming = false;
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (!gameOver) isAiming = true;
            aimingX = Math.max(nextObject.radius, Math.min(canvas.width - nextObject.radius, e.clientX - canvas.offsetLeft));
        });

        canvas.addEventListener('mousemove', (e) => {
            e.preventDefault();
            if (isAiming && !gameOver) {
                aimingX = Math.max(nextObject.radius, Math.min(canvas.width - nextObject.radius, e.clientX - canvas.offsetLeft));
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            if (isAiming && !gameOver) {
                spawnSpaceObject();
                isAiming = false;
            }
        });

        gameLoop();
    </script>
</body>
</html>