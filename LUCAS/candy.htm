<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Frutas - Match 3</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #87CEEB;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #333;
            background-color: #F5F5F5;
            touch-action: none;
        }
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #333;
            font-size: 20px;
            font-weight: bold;
            transition: color 0.5s ease-in-out;
        }
        #score.pulse {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); color: #FF0000; }
            50% { transform: scale(1.2); color: #FF4444; }
        }
        #score.scoreAdd {
            animation: scoreAdd 0.5s ease-out;
        }
        @keyframes scoreAdd {
            0% { transform: scale(1); color: #333; }
            50% { transform: scale(1.3); color: #00FF00; }
            100% { transform: scale(1); color: #333; }
        }
        #lives {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
        }
        #lives.lifeLost {
            animation: lifeLost 0.5s ease-out;
        }
        @keyframes lifeLost {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: #FF0000; }
            100% { transform: scale(1); color: #000; }
        }
        #timer {
            position: absolute;
            top: 40px;
            right: 10px;
            color: #333;
            font-size: 20px;
            font-weight: bold;
        }
        #timer.pulseGreen {
            animation: pulseGreen 1s infinite;
        }
        @keyframes pulseGreen {
            0%, 100% { transform: scale(1); color: #00FF00; }
            50% { transform: scale(1.2); color: #00CC00; }
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            font-size: 24px;
            text-align: center;
            display: none;
        }
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            font-size: 14px;
            text-align: center;
            width: 80%;
            max-width: 600px;
        }
        #startButton {
            margin-top: 10px;
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #startButton:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Puntaje: 0</div>
    <div id="lives">❤️❤️❤️❤️❤️</div>
    <div id="timer">Tiempo: 180s</div>
    <div id="gameOver"><span id="gameResult">Fin!</span><br>Puntuación: <span id="finalScore">0</span></div>
    <div id="startScreen">
        <h2>¡Bienvenido al Juego de Frutas Match-3!</h2>
        <p>Reglas:</p>
        <ul style="text-align: left; padding-left: 20px;">
            <li>Tienes 5 vidas iniciales (máximo 5).</li>
            <li>Intercambia frutas adyacentes para alinear 3 o más iguales.</li>
            <li>3 frutas = 10 puntos, 4 frutas = 20 puntos, 5 frutas = 50 puntos.</li>
            <li>Si no haces movimientos en 5 segundos, pierdes 1 vida.</li>
            <li>Combina 5 frutas para ganar una vida extra.</li>
            <li>Ganas si el temporizador de 3 minutos llega a 0. Puntuación: vidas × puntaje.</li>
            <li>Pierdes si te quedas sin vidas.</li>
        </ul>
        <button id="startButton">Comenzar</button>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const timerDisplay = document.getElementById('timer');
        const gameOverDisplay = document.getElementById('gameOver');
        const gameResultDisplay = document.getElementById('gameResult');
        const finalScoreDisplay = document.getElementById('finalScore');
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');

        canvas.width = Math.min(window.innerWidth * 0.9, 400);
        canvas.height = Math.min(window.innerHeight * 0.9, 600) - 50;

        const GRID_SIZE = 8;
        const CELL_SIZE = canvas.width / GRID_SIZE;
        const INITIAL_LIVES = 5;
        const MAX_LIVES = 5;
        const GAME_DURATION = 180;
        const INACTIVITY_THRESHOLD = 5000;
        const ANIMATION_DURATION = 200; // Milisegundos para las animaciones

        let score = 0;
        let lives = INITIAL_LIVES;
        let gameTime = GAME_DURATION;
        let lastMoveTime = Date.now();
        let gameOver = false;
        let gameStarted = false;
        let useImages = true;
        let gameStartTime;
        let isAnimating = false; // Controlar animaciones en curso

        const fruitImages = {};
        const fruitTypes = 6;
        let imagesLoaded = 0;
        let allImagesLoaded = false;

        function loadFruitImages() {
            for (let i = 0; i < fruitTypes; i++) {
                fruitImages[i] = new Image();
                fruitImages[i].src = `images/fruit${i}.png`;
                fruitImages[i].onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === fruitTypes) allImagesLoaded = true;
                };
                fruitImages[i].onerror = () => {
                    console.error(`Error al cargar fruit${i}.png`);
                    useImages = false;
                };
            }
        }
        loadFruitImages();

        class Fruit {
            constructor(row, col, type) {
                this.row = row;
                this.col = col;
                this.type = type;
                this.size = CELL_SIZE * 0.8;
                this.isMarked = false;
                this.x = col * CELL_SIZE + CELL_SIZE / 2; // Posición actual en píxeles
                this.y = row * CELL_SIZE + CELL_SIZE / 2;
                this.targetX = this.x; // Posición objetivo
                this.targetY = this.y;
                this.opacity = 1; // Para animación de desaparición
                this.animationStart = null;
            }

            update() {
                if (this.animationStart !== null) {
                    const elapsed = Date.now() - this.animationStart;
                    const progress = Math.min(elapsed / ANIMATION_DURATION, 1);

                    if (this.isMarked) {
                        // Animación de desaparición
                        this.opacity = 1 - progress;
                        if (progress >= 1) {
                            this.animationStart = null;
                        }
                    } else {
                        // Animación de movimiento
                        this.x = this.x + (this.targetX - this.x) * progress;
                        this.y = this.y + (this.targetY - this.y) * progress;
                        if (progress >= 1) {
                            this.x = this.targetX;
                            this.y = this.targetY;
                            this.animationStart = null;
                        }
                    }
                }
            }

            draw() {
                if (this.opacity <= 0) return; // No dibujar si ya desapareció
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.globalAlpha = this.opacity;
                if (useImages && allImagesLoaded) {
                    ctx.drawImage(fruitImages[this.type], -this.size / 2, -this.size / 2, this.size, this.size);
                } else {
                    const colors = ['#1E90FF', '#90EE90', '#FF4040', '#800080', '#FFA500', '#FF1493'];
                    ctx.fillStyle = colors[this.type];
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            startAnimation(targetRow, targetCol) {
                this.targetX = targetCol * CELL_SIZE + CELL_SIZE / 2;
                this.targetY = targetRow * CELL_SIZE + CELL_SIZE / 2;
                this.animationStart = Date.now();
                this.row = targetRow;
                this.col = targetCol;
            }

            startFade() {
                this.animationStart = Date.now();
            }
        }

        let grid = [];
        let selectedFruit = null;

        function initializeGrid() {
            grid = [];
            for (let row = 0; row < GRID_SIZE; row++) {
                grid[row] = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    grid[row][col] = new Fruit(row, col, Math.floor(Math.random() * fruitTypes));
                }
            }
            removeInitialMatches();
        }

        function removeInitialMatches() {
            let hasMatches = true;
            while (hasMatches) {
                hasMatches = false;
                const matches = findMatches();
                if (matches.length > 0) {
                    hasMatches = true;
                    matches.forEach(match => {
                        match.forEach(([row, col]) => {
                            grid[row][col] = new Fruit(row, col, Math.floor(Math.random() * fruitTypes));
                        });
                    });
                }
            }
        }

        function findMatches() {
            let matches = [];
            for (let row = 0; row < GRID_SIZE; row++) {
                let count = 1;
                let startCol = 0;
                for (let col = 1; col < GRID_SIZE; col++) {
                    if (grid[row][col].type === grid[row][col - 1].type) {
                        count++;
                    } else {
                        if (count >= 3) {
                            let match = [];
                            for (let i = startCol; i < startCol + count; i++) {
                                match.push([row, i]);
                            }
                            matches.push(match);
                        }
                        count = 1;
                        startCol = col;
                    }
                }
                if (count >= 3) {
                    let match = [];
                    for (let i = startCol; i < startCol + count; i++) {
                        match.push([row, i]);
                    }
                    matches.push(match);
                }
            }
            for (let col = 0; col < GRID_SIZE; col++) {
                let count = 1;
                let startRow = 0;
                for (let row = 1; row < GRID_SIZE; row++) {
                    if (grid[row][col].type === grid[row - 1][col].type) {
                        count++;
                    } else {
                        if (count >= 3) {
                            let match = [];
                            for (let i = startRow; i < startRow + count; i++) {
                                match.push([i, col]);
                            }
                            matches.push(match);
                        }
                        count = 1;
                        startRow = row;
                    }
                }
                if (count >= 3) {
                    let match = [];
                    for (let i = startRow; i < startRow + count; i++) {
                        match.push([i, col]);
                    }
                    matches.push(match);
                }
            }
            return matches;
        }

        function removeMatches() {
            const matches = findMatches();
            if (matches.length === 0) return;
            isAnimating = true;
            matches.forEach(match => {
                match.forEach(([row, col]) => {
                    grid[row][col].isMarked = true;
                    grid[row][col].startFade();
                });
                let points = match.length === 3 ? 10 : match.length === 4 ? 20 : 50;
                score += points;
                if (match.length >= 5 && lives < MAX_LIVES) {
                    lives++;
                    updateLivesDisplay();
                }
            });
            scoreDisplay.textContent = `Puntaje: ${score}`;
            scoreDisplay.classList.add('scoreAdd');
            setTimeout(() => scoreDisplay.classList.remove('scoreAdd'), 500);
            setTimeout(() => {
                dropFruits();
                isAnimating = false;
            }, ANIMATION_DURATION);
        }

        function dropFruits() {
            isAnimating = true;
            for (let col = 0; col < GRID_SIZE; col++) {
                let emptySpaces = 0;
                for (let row = GRID_SIZE - 1; row >= 0; row--) {
                    if (grid[row][col].isMarked) {
                        emptySpaces++;
                        grid[row][col] = null;
                    } else if (emptySpaces > 0) {
                        grid[row + emptySpaces][col] = grid[row][col];
                        grid[row + emptySpaces][col].startAnimation(row + emptySpaces, col);
                        grid[row][col] = null;
                    }
                }
                for (let i = 0; i < emptySpaces; i++) {
                    grid[i][col] = new Fruit(i, col, Math.floor(Math.random() * fruitTypes));
                    grid[i][col].y = -CELL_SIZE / 2; // Comienza fuera del canvas
                    grid[i][col].startAnimation(i, col);
                }
            }
            setTimeout(() => {
                const newMatches = findMatches();
                if (newMatches.length > 0) removeMatches();
                else isAnimating = false;
            }, ANIMATION_DURATION);
        }

        function swapFruits(row1, col1, row2, col2) {
            if (isAnimating || Math.abs(row1 - row2) + Math.abs(col1 - col2) !== 1) return;
            isAnimating = true;
            const fruit1 = grid[row1][col1];
            const fruit2 = grid[row2][col2];
            grid[row1][col1] = fruit2;
            grid[row2][col2] = fruit1;
            fruit1.startAnimation(row2, col2);
            fruit2.startAnimation(row1, col1);

            setTimeout(() => {
                const matches = findMatches();
                if (matches.length === 0) {
                    // Revertir si no hay coincidencias
                    grid[row1][col1] = fruit1;
                    grid[row2][col2] = fruit2;
                    fruit1.startAnimation(row1, col1);
                    fruit2.startAnimation(row2, col2);
                    setTimeout(() => isAnimating = false, ANIMATION_DURATION);
                } else {
                    lastMoveTime = Date.now();
                    removeMatches();
                }
            }, ANIMATION_DURATION);
        }

        function updateLivesDisplay() {
            let hearts = '';
            for (let i = 0; i < MAX_LIVES; i++) {
                hearts += i < lives ? '❤️' : '🖤';
            }
            livesDisplay.textContent = hearts;
        }

        function updateTimer() {
            if (gameOver || !gameStarted) return;
            const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
            gameTime = GAME_DURATION - elapsed;
            timerDisplay.textContent = `Tiempo: ${gameTime}s`;
            if (gameTime <= 60) {
                timerDisplay.classList.add('pulseGreen');
            } else {
                timerDisplay.classList.remove('pulseGreen');
            }
            if (gameTime <= 0) endGame(true);
        }

        function checkInactivity() {
            if (gameOver || !gameStarted) return;
            const timeSinceLastMove = Date.now() - lastMoveTime;
            if (timeSinceLastMove >= INACTIVITY_THRESHOLD) {
                lives--;
                updateLivesDisplay();
                lastMoveTime = Date.now();
                livesDisplay.classList.add('lifeLost');
                setTimeout(() => livesDisplay.classList.remove('lifeLost'), 500);
                if (lives <= 0) endGame(false);
            }
        }

        function endGame(won) {
            gameOver = true;
            gameOverDisplay.style.display = 'block';
            if (won) {
                gameResultDisplay.textContent = '¡Ganaste!';
                finalScoreDisplay.textContent = lives * score;
            } else {
                gameResultDisplay.textContent = 'Perdiste';
                finalScoreDisplay.textContent = 0;
            }
        }

        function startGame() {
            gameStarted = true;
            gameStartTime = Date.now();
            lastMoveTime = Date.now();
            startScreen.style.display = 'none';
            setInterval(updateTimer, 1000);
            setInterval(checkInactivity, 1000);
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Dibujar cuadrícula
            ctx.strokeStyle = '#333';
            for (let row = 0; row <= GRID_SIZE; row++) {
                ctx.beginPath();
                ctx.moveTo(0, row * CELL_SIZE);
                ctx.lineTo(canvas.width, row * CELL_SIZE);
                ctx.stroke();
            }
            for (let col = 0; col <= GRID_SIZE; col++) {
                ctx.beginPath();
                ctx.moveTo(col * CELL_SIZE, 0);
                ctx.lineTo(col * CELL_SIZE, canvas.height);
                ctx.stroke();
            }

            // Actualizar y dibujar frutas
            if (grid.length > 0) {
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (grid[row][col]) {
                            grid[row][col].update();
                            grid[row][col].draw();
                        }
                    }
                }
            }

            // Resaltar fruta seleccionada
            if (selectedFruit && !isAnimating) {
                const x = selectedFruit.col * CELL_SIZE;
                const y = selectedFruit.row * CELL_SIZE;
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, CELL_SIZE, CELL_SIZE);
            }

            requestAnimationFrame(gameLoop);
        }

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (!gameOver && gameStarted && !isAnimating) {
                const x = e.clientX - canvas.offsetLeft;
                const y = e.clientY - canvas.offsetTop;
                const col = Math.floor(x / CELL_SIZE);
                const row = Math.floor(y / CELL_SIZE);
                if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
                    selectedFruit = { row, col };
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            e.preventDefault();
            if (!gameOver && gameStarted && selectedFruit && !isAnimating) {
                const x = e.clientX - canvas.offsetLeft;
                const y = e.clientY - canvas.offsetTop;
                const col = Math.floor(x / CELL_SIZE);
                const row = Math.floor(y / CELL_SIZE);
                if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE &&
                    (row !== selectedFruit.row || col !== selectedFruit.col)) {
                    swapFruits(selectedFruit.row, selectedFruit.col, row, col);
                    selectedFruit = null;
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            selectedFruit = null;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameOver && gameStarted && !isAnimating) {
                const touchX = e.touches[0].clientX - canvas.offsetLeft;
                const touchY = e.touches[0].clientY - canvas.offsetTop;
                const col = Math.floor(touchX / CELL_SIZE);
                const row = Math.floor(touchY / CELL_SIZE);
                if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
                    selectedFruit = { row, col };
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!gameOver && gameStarted && selectedFruit && !isAnimating) {
                const touchX = e.touches[0].clientX - canvas.offsetLeft;
                const touchY = e.touches[0].clientY - canvas.offsetTop;
                const col = Math.floor(touchX / CELL_SIZE);
                const row = Math.floor(touchY / CELL_SIZE);
                if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE &&
                    (row !== selectedFruit.row || col !== selectedFruit.col)) {
                    swapFruits(selectedFruit.row, selectedFruit.col, row, col);
                    selectedFruit = null;
                }
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            selectedFruit = null;
        });

        startButton.addEventListener('click', startGame);

        initializeGrid();
        gameLoop();
    </script>
</body>
</html>