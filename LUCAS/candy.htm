<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Frutas - Match 3</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #87CEEB;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #333;
            background-color: #F5F5F5;
            touch-action: none;
        }
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #333;
            font-size: 20px;
            font-weight: bold;
            transition: color 0.5s ease-in-out;
        }
        #score.scoreAdd {
            animation: scoreAdd 0.5s ease-out;
        }
        @keyframes scoreAdd {
            0% { transform: scale(1); color: #333; }
            50% { transform: scale(1.3); color: #00FF00; }
            100% { transform: scale(1); color: #333; }
        }
        #moves {
            position: absolute;
            top: 40px;
            right: 10px;
            color: #333;
            font-size: 20px;
            font-weight: bold;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            font-size: 24px;
            text-align: center;
            display: none;
        }
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            font-size: 14px;
            text-align: center;
            width: 80%;
            max-width: 600px;
        }
        #startButton {
            margin-top: 10px;
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #startButton:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Puntaje: 0 / 1000</div>
    <div id="moves">Movimientos: 50</div>
    <div id="gameOver"><span id="gameResult">Fin!</span><br>Puntuaci√≥n: <span id="finalScore">0</span></div>
    <div id="startScreen">
        <h2>¬°Bienvenido al Juego de Frutas Match-3!</h2>
        <p>Reglas:</p>
        <ul style="text-align: left; padding-left: 20px;">
            <li>Tienes 50 movimientos para alcanzar 1000 puntos.</li>
            <li>3 frutas = 10 puntos; 4 en l√≠nea = 20 puntos (bomba); 5 en l√≠nea = 50 puntos (sand√≠a).</li>
            <li>5 en "L" = bomba; 4 en 2x2 = abejitas (explotan 4 frutas aleatorias).</li>
            <li>Bomba explota en +1 con 2+ de su tipo; Bomba + Bomba = +2.</li>
            <li>Sand√≠a elimina un tipo; Bomba + Sand√≠a = bombas + explosi√≥n.</li>
            <li>Frutas especiales aparecen en la fruta que genera la fusi√≥n y se activan en grupos de 3+.</li>
            <li>Ganas con 1000+ puntos antes de quedarte sin movimientos.</li>
        </ul>
        <button id="startButton">Comenzar</button>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const movesDisplay = document.getElementById('moves');
        const gameOverDisplay = document.getElementById('gameOver');
        const gameResultDisplay = document.getElementById('gameResult');
        const finalScoreDisplay = document.getElementById('finalScore');
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');

        canvas.width = Math.min(window.innerWidth * 0.9, 400);
        canvas.height = 11 * (canvas.width / 8);

        const GRID_SIZE_ROWS = 11;
        const GRID_SIZE_COLS = 8;
        const CELL_SIZE = canvas.width / GRID_SIZE_COLS;
        const INITIAL_MOVES = 50;
        const SCORE_GOAL = 1000;
        const ANIMATION_DURATION = 200;
        const EXPLOSION_ANIMATION_DURATION = 300;
        const BEE_ANIMATION_DURATION = 500;

        let score = 0;
        let moves = INITIAL_MOVES;
        let gameOver = false;
        let gameStarted = false;
        let useImages = true;
        let isAnimating = false;
        let lastSwap = null;

        const fruitImages = {};
        const fruitTypes = 6;
        let imagesLoaded = 0;
        let allImagesLoaded = false;

        function loadFruitImages() {
            for (let i = 0; i < fruitTypes; i++) {
                fruitImages[i] = new Image();
                fruitImages[i].src = `images/fruit${i}.png`;
                fruitImages[i].onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === fruitTypes) allImagesLoaded = true;
                };
                fruitImages[i].onerror = () => {
                    console.error(`Error al cargar fruit${i}.png`);
                    useImages = false;
                };
            }
        }
        loadFruitImages();

        class Fruit {
            constructor(row, col, type, isBomb = false, isWatermelon = false, isBee = false) {
                this.row = row;
                this.col = col;
                this.type = type;
                this.size = CELL_SIZE * 0.8;
                this.isMarked = false;
                this.isBomb = isBomb;
                this.isWatermelon = isWatermelon;
                this.isBee = isBee;
                this.x = col * CELL_SIZE + CELL_SIZE / 2;
                this.y = row * CELL_SIZE + CELL_SIZE / 2;
                this.targetX = this.x;
                this.targetY = this.y;
                this.opacity = 1;
                this.animationStart = null;
                this.blink = 0;
                this.explosionStart = null;
            }

            update() {
                if (this.animationStart !== null) {
                    const elapsed = Date.now() - this.animationStart;
                    const progress = Math.min(elapsed / ANIMATION_DURATION, 1);
                    if (this.isMarked && !this.explosionStart) {
                        this.opacity = 1 - progress;
                        if (progress >= 1) this.animationStart = null;
                    } else {
                        this.x = this.x + (this.targetX - this.x) * progress;
                        this.y = this.y + (this.targetY - this.y) * progress;
                        if (progress >= 1) {
                            this.x = this.targetX;
                            this.y = this.targetY;
                            this.animationStart = null;
                        }
                    }
                }
                if (this.explosionStart !== null) {
                    const elapsed = Date.now() - this.explosionStart;
                    const progress = Math.min(elapsed / EXPLOSION_ANIMATION_DURATION, 1);
                    this.opacity = 1 - progress;
                    if (progress >= 1) this.explosionStart = null;
                }
                if (this.isBomb || this.isWatermelon || this.isBee) {
                    this.blink = (this.blink + 0.1) % (2 * Math.PI);
                }
            }

            draw() {
                if (this.opacity <= 0) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.globalAlpha = this.opacity;
                let scale = 1;
                if (this.isBomb || this.isWatermelon || this.isBee) {
                    scale = 1 + Math.sin(this.blink) * 0.1;
                }
                if (this.explosionStart !== null) {
                    scale *= 1 + Math.sin(Date.now() * 0.02) * 0.2;
                    ctx.fillStyle = 'rgba(255, 165, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size / 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.scale(scale, scale);
                if (useImages && allImagesLoaded) {
                    ctx.drawImage(fruitImages[this.type], -this.size / 2, -this.size / 2, this.size, this.size);
                } else {
                    const colors = ['#1E90FF', '#90EE90', '#FF4040', '#800080', '#FFA500', '#FF1493'];
                    ctx.fillStyle = colors[this.type];
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                if (this.isBomb) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `${this.size / 2}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üí£', 0, 0);
                } else if (this.isWatermelon) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `${this.size / 2}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üçâ', 0, 0);
                } else if (this.isBee) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `${this.size / 2}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üêù', 0, 0);
                }
                ctx.restore();
            }

            startAnimation(targetRow, targetCol) {
                this.targetX = targetCol * CELL_SIZE + CELL_SIZE / 2;
                this.targetY = targetRow * CELL_SIZE + CELL_SIZE / 2;
                this.animationStart = Date.now();
                this.row = targetRow;
                this.col = targetCol;
            }

            startFade() {
                this.animationStart = Date.now();
            }

            startExplosion() {
                this.explosionStart = Date.now();
                this.isMarked = true;
            }
        }

        let grid = [];
        let selectedFruit = null;
        let bees = [];

        function initializeGrid() {
            grid = [];
            for (let row = 0; row < GRID_SIZE_ROWS; row++) {
                grid[row] = [];
                for (let col = 0; col < GRID_SIZE_COLS; col++) {
                    grid[row][col] = new Fruit(row, col, Math.floor(Math.random() * fruitTypes));
                }
            }
            removeInitialMatches();
        }

        function removeInitialMatches() {
            let hasMatches = true;
            while (hasMatches) {
                hasMatches = false;
                const matches = findMatches();
                if (matches.length > 0) {
                    hasMatches = true;
                    matches.forEach(match => {
                        match.forEach(([row, col]) => {
                            grid[row][col] = new Fruit(row, col, Math.floor(Math.random() * fruitTypes));
                        });
                    });
                }
            }
        }

        function findMatches() {
            let matches = [];
            for (let row = 0; row < GRID_SIZE_ROWS; row++) {
                let count = 1;
                let startCol = 0;
                for (let col = 1; col < GRID_SIZE_COLS; col++) {
                    if (grid[row][col] && grid[row][col - 1] && grid[row][col].type === grid[row][col - 1].type) {
                        count++;
                    } else {
                        if (count >= 3) {
                            let match = [];
                            for (let i = startCol; i < startCol + count; i++) {
                                match.push([row, i]);
                            }
                            matches.push(match);
                        }
                        count = 1;
                        startCol = col;
                    }
                }
                if (count >= 3) {
                    let match = [];
                    for (let i = startCol; i < startCol + count; i++) {
                        match.push([row, i]);
                    }
                    matches.push(match);
                }
            }
            for (let col = 0; col < GRID_SIZE_COLS; col++) {
                let count = 1;
                let startRow = 0;
                for (let row = 1; row < GRID_SIZE_ROWS; row++) {
                    if (grid[row][col] && grid[row - 1][col] && grid[row][col].type === grid[row - 1][col].type) {
                        count++;
                    } else {
                        if (count >= 3) {
                            let match = [];
                            for (let i = startRow; i < startRow + count; i++) {
                                match.push([i, col]);
                            }
                            matches.push(match);
                        }
                        count = 1;
                        startRow = row;
                    }
                }
                if (count >= 3) {
                    let match = [];
                    for (let i = startRow; i < startRow + count; i++) {
                        match.push([i, col]);
                    }
                    matches.push(match);
                }
            }
            return matches;
        }

        function findAngleMatches(row, col) {
            const type = grid[row][col].type;
            const patterns = [
                [[0, 0], [1, 0], [2, 0], [0, 1], [0, 2]], // L hacia abajo-derecha
                [[0, 0], [1, 0], [2, 0], [0, -1], [0, -2]], // L hacia abajo-izquierda
                [[0, 0], [-1, 0], [-2, 0], [0, 1], [0, 2]], // L hacia arriba-derecha
                [[0, 0], [-1, 0], [-2, 0], [0, -1], [0, -2]] // L hacia arriba-izquierda
            ];
            for (let pattern of patterns) {
                let valid = true;
                for (let [dr, dc] of pattern) {
                    let r = row + dr;
                    let c = col + dc;
                    if (r < 0 || r >= GRID_SIZE_ROWS || c < 0 || c >= GRID_SIZE_COLS || !grid[r][c] || grid[r][c].type !== type) {
                        valid = false;
                        break;
                    }
                }
                if (valid) return pattern.map(([dr, dc]) => [row + dr, col + dc]);
            }
            return [];
        }

        function findSquareMatches(row, col) {
            const type = grid[row][col].type;
            const patterns = [
                [[0, 0], [0, 1], [1, 0], [1, 1]], // 2x2 desde esquina superior izquierda
                [[0, 0], [0, -1], [1, 0], [1, -1]], // 2x2 desde esquina superior derecha
                [[0, 0], [0, 1], [-1, 0], [-1, 1]], // 2x2 desde esquina inferior izquierda
                [[0, 0], [0, -1], [-1, 0], [-1, -1]] // 2x2 desde esquina inferior derecha
            ];
            for (let pattern of patterns) {
                let valid = true;
                for (let [dr, dc] of pattern) {
                    let r = row + dr;
                    let c = col + dc;
                    if (r < 0 || r >= GRID_SIZE_ROWS || c < 0 || c >= GRID_SIZE_COLS || !grid[r][c] || grid[r][c].type !== type) {
                        valid = false;
                        break;
                    }
                }
                if (valid) return pattern.map(([dr, dc]) => [row + dr, col + dc]);
            }
            return [];
        }

        function findBombMatches(bombRow, bombCol) {
            const bomb = grid[bombRow][bombCol];
            if (!bomb || !bomb.isBomb) return [];
            let matches = [];
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            directions.forEach(([dr, dc]) => {
                let row = bombRow + dr;
                let col = bombCol + dc;
                let count = 0;
                let match = [];
                while (row >= 0 && row < GRID_SIZE_ROWS && col >= 0 && col < GRID_SIZE_COLS && grid[row][col] && grid[row][col].type === bomb.type && !grid[row][col].isBomb && !grid[row][col].isWatermelon && !grid[row][col].isBee) {
                    match.push([row, col]);
                    count++;
                    row += dr;
                    col += dc;
                }
                if (count >= 2) {
                    matches.push(match);
                }
            });
            return matches;
        }

        function explodeBomb(row, col, radius) {
            for (let r = Math.max(0, row - radius); r <= Math.min(GRID_SIZE_ROWS - 1, row + radius); r++) {
                for (let c = Math.max(0, col - radius); c <= Math.min(GRID_SIZE_COLS - 1, col + radius); c++) {
                    if (grid[r][c] && !grid[r][c].explosionStart) {
                        grid[r][c].startExplosion();
                    }
                }
            }
        }

        function explodeBee(row, col) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (let [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                if (r >= 0 && r < GRID_SIZE_ROWS && c >= 0 && c < GRID_SIZE_COLS && grid[r][c] && !grid[r][c].explosionStart) {
                    grid[r][c].startExplosion();
                }
            }
        }

        function animateBees(match, callback) {
            bees = match.map(([r, c]) => ({
                x: c * CELL_SIZE + CELL_SIZE / 2,
                y: r * CELL_SIZE + CELL_SIZE / 2,
                targetX: null,
                targetY: null,
                startTime: Date.now(),
                landed: false
            }));
            bees.forEach(bee => {
                let targetRow, targetCol;
                do {
                    targetRow = Math.floor(Math.random() * GRID_SIZE_ROWS);
                    targetCol = Math.floor(Math.random() * GRID_SIZE_COLS);
                } while (!grid[targetRow][targetCol] || grid[targetRow][targetCol].isMarked);
                bee.targetX = targetCol * CELL_SIZE + CELL_SIZE / 2;
                bee.targetY = targetRow * CELL_SIZE + CELL_SIZE / 2;
            });

            function updateBees() {
                bees.forEach(bee => {
                    if (!bee.landed) {
                        const elapsed = Date.now() - bee.startTime;
                        const progress = Math.min(elapsed / BEE_ANIMATION_DURATION, 1);
                        bee.x += (bee.targetX - bee.x) * 0.1 + (Math.random() - 0.5) * 10;
                        bee.y += (bee.targetY - bee.y) * 0.1 + (Math.random() - 0.5) * 10;
                        if (progress >= 1) {
                            bee.x = bee.targetX;
                            bee.y = bee.targetY;
                            bee.landed = true;
                            const row = Math.floor(bee.y / CELL_SIZE);
                            const col = Math.floor(bee.x / CELL_SIZE);
                            explodeBee(row, col);
                            score += 10;
                            scoreDisplay.textContent = `Puntaje: ${score} / ${SCORE_GOAL}`;
                        }
                    }
                });
                if (bees.every(bee => bee.landed)) {
                    bees = [];
                    callback();
                } else {
                    requestAnimationFrame(updateBees);
                }
            }
            updateBees();
        }

        function removeMatches() {
            const matches = findMatches();
            if (matches.length === 0) return;
            isAnimating = true;
            let hasSpecial = false;
            let specialPos = null;

            matches.forEach(match => {
                let bombs = [];
                let watermelons = [];
                let bees = [];
                match.forEach(([row, col]) => {
                    if (grid[row][col].isBomb) bombs.push([row, col]);
                    if (grid[row][col].isWatermelon) watermelons.push([row, col]);
                    if (grid[row][col].isBee) bees.push([row, col]);
                    grid[row][col].isMarked = true;
                    grid[row][col].startFade();
                });
                let points = match.length === 3 ? 10 : match.length === 4 ? 20 : 50;
                score += points;

                // Determinar la posici√≥n de la fruta que gener√≥ la fusi√≥n
                if (lastSwap) {
                    const [r1, c1] = [lastSwap.row1, lastSwap.col1];
                    const [r2, c2] = [lastSwap.row2, lastSwap.col2];
                    specialPos = match.some(([r, c]) => r === r1 && c === c1) ? [r1, c1] : [r2, c2];
                } else {
                    specialPos = match[Math.floor(match.length / 2)];
                }

                if (match.length === 4 && bombs.length === 0 && watermelons.length === 0 && bees.length === 0) {
                    setTimeout(() => {
                        grid[specialPos[0]][specialPos[1]] = new Fruit(specialPos[0], specialPos[1], grid[specialPos[0]][specialPos[1]].type, true);
                    }, ANIMATION_DURATION);
                } else if (match.length >= 5 && bombs.length === 0 && watermelons.length === 0 && bees.length === 0) {
                    setTimeout(() => {
                        grid[specialPos[0]][specialPos[1]] = new Fruit(specialPos[0], specialPos[1], grid[specialPos[0]][specialPos[1]].type, false, true);
                    }, ANIMATION_DURATION);
                }
                if (bombs.length > 0 || watermelons.length > 0 || bees.length > 0) hasSpecial = true;
                bombs.forEach(([r, c]) => {
                    explodeBomb(r, c, 1);
                    score += 15;
                });
                watermelons.forEach(([r, c]) => {
                    const typeToRemove = grid[r][c].type;
                    for (let i = 0; i < GRID_SIZE_ROWS; i++) {
                        for (let j = 0; j < GRID_SIZE_COLS; j++) {
                            if (grid[i][j] && grid[i][j].type === typeToRemove) {
                                grid[i][j].isMarked = true;
                                grid[i][j].startFade();
                            }
                        }
                    }
                    score += 50;
                });
                bees.forEach(([r, c]) => {
                    explodeBee(r, c);
                    score += 10;
                });
            });

            if (lastSwap) {
                const angleMatch1 = findAngleMatches(lastSwap.row1, lastSwap.col1);
                const angleMatch2 = findAngleMatches(lastSwap.row2, lastSwap.col2);
                const angleMatch = angleMatch1.length > 0 ? angleMatch1 : angleMatch2;
                specialPos = angleMatch === angleMatch1 ? [lastSwap.row1, lastSwap.col1] : [lastSwap.row2, lastSwap.col2];
                if (angleMatch.length > 0 && !hasSpecial) {
                    angleMatch.forEach(([r, c]) => {
                        grid[r][c].isMarked = true;
                        grid[r][c].startFade();
                    });
                    score += 50;
                    setTimeout(() => {
                        grid[specialPos[0]][specialPos[1]] = new Fruit(specialPos[0], specialPos[1], grid[specialPos[0]][specialPos[1]].type, true);
                    }, ANIMATION_DURATION);
                    hasSpecial = true;
                }

                const squareMatch1 = findSquareMatches(lastSwap.row1, lastSwap.col1);
                const squareMatch2 = findSquareMatches(lastSwap.row2, lastSwap.col2);
                const squareMatch = squareMatch1.length > 0 ? squareMatch1 : squareMatch2;
                specialPos = squareMatch === squareMatch1 ? [lastSwap.row1, lastSwap.col1] : [lastSwap.row2, lastSwap.col2];
                if (squareMatch.length > 0 && !hasSpecial) {
                    squareMatch.forEach(([r, c]) => {
                        grid[r][c].isMarked = true;
                        grid[r][c].startFade();
                    });
                    score += 20;
                    setTimeout(() => {
                        grid[specialPos[0]][specialPos[1]] = new Fruit(specialPos[0], specialPos[1], grid[specialPos[0]][specialPos[1]].type, false, false, true);
                        animateBees(squareMatch, () => {
                            for (let r = 0; r < GRID_SIZE_ROWS; r++) {
                                for (let c = 0; c < GRID_SIZE_COLS; c++) {
                                    if (grid[r][c] && grid[r][c].isMarked) grid[r][c] = null;
                                }
                            }
                            dropFruits();
                            isAnimating = false;
                        });
                    }, ANIMATION_DURATION);
                    hasSpecial = true;
                }
            }

            scoreDisplay.textContent = `Puntaje: ${score} / ${SCORE_GOAL}`;
            scoreDisplay.classList.add('scoreAdd');
            setTimeout(() => scoreDisplay.classList.remove('scoreAdd'), 500);
            setTimeout(() => {
                if (hasSpecial) {
                    setTimeout(() => {
                        for (let r = 0; r < GRID_SIZE_ROWS; r++) {
                            for (let c = 0; c < GRID_SIZE_COLS; c++) {
                                if (grid[r][c] && grid[r][c].isMarked) grid[r][c] = null;
                            }
                        }
                        dropFruits();
                        isAnimating = false;
                    }, Math.max(EXPLOSION_ANIMATION_DURATION, squareMatch.length > 0 ? BEE_ANIMATION_DURATION : 0));
                } else {
                    dropFruits();
                    isAnimating = false;
                }
            }, hasSpecial ? EXPLOSION_ANIMATION_DURATION : ANIMATION_DURATION);
        }

        function dropFruits() {
            isAnimating = true;
            for (let col = 0; col < GRID_SIZE_COLS; col++) {
                let emptySpaces = 0;
                for (let row = GRID_SIZE_ROWS - 1; row >= 0; row--) {
                    if (!grid[row][col] || grid[row][col].isMarked) {
                        emptySpaces++;
                        grid[row][col] = null;
                    } else if (emptySpaces > 0) {
                        grid[row + emptySpaces][col] = grid[row][col];
                        grid[row + emptySpaces][col].startAnimation(row + emptySpaces, col);
                        grid[row][col] = null;
                    }
                }
                for (let i = 0; i < emptySpaces; i++) {
                    grid[i][col] = new Fruit(i, col, Math.floor(Math.random() * fruitTypes));
                    grid[i][col].y = -CELL_SIZE / 2;
                    grid[i][col].startAnimation(i, col);
                }
            }
            setTimeout(() => {
                const newMatches = findMatches();
                if (newMatches.length > 0) removeMatches();
                else isAnimating = false;
            }, ANIMATION_DURATION);
        }

        function swapFruits(row1, col1, row2, col2) {
            if (isAnimating || Math.abs(row1 - row2) + Math.abs(col1 - col2) !== 1 || !grid[row1][col1] || !grid[row2][col2]) return;
            isAnimating = true;
            moves--;
            movesDisplay.textContent = `Movimientos: ${moves}`;
            if (moves <= 0) {
                setTimeout(() => endGame(score >= SCORE_GOAL), ANIMATION_DURATION);
                return;
            }
            const fruit1 = grid[row1][col1];
            const fruit2 = grid[row2][col2];
            grid[row1][col1] = fruit2;
            grid[row2][col2] = fruit1;
            fruit1.startAnimation(row2, col2);
            fruit2.startAnimation(row1, col1);
            lastSwap = { row1, col1, row2, col2 };

            setTimeout(() => {
                const matches = findMatches();
                const angleMatch1 = findAngleMatches(row1, col1);
                const angleMatch2 = findAngleMatches(row2, col2);
                const squareMatch1 = findSquareMatches(row1, col1);
                const squareMatch2 = findSquareMatches(row2, col2);
                if (matches.length > 0 || angleMatch1.length > 0 || angleMatch2.length > 0 || squareMatch1.length > 0 || squareMatch2.length > 0) {
                    removeMatches();
                } else if (fruit1.isBomb) {
                    const bombMatches = findBombMatches(row2, col2);
                    if (bombMatches.length > 0 && bombMatches.some(match => match.length >= 2)) {
                        explodeBomb(row2, col2, 1);
                        grid[row2][col2].startExplosion();
                        bombMatches.forEach(match => match.forEach(([r, c]) => grid[r][c].startExplosion()));
                        setTimeout(() => {
                            grid[row2][col2] = null;
                            bombMatches.forEach(match => match.forEach(([r, c]) => grid[r][c] = null));
                            dropFruits();
                            isAnimating = false;
                        }, EXPLOSION_ANIMATION_DURATION);
                        score += 15;
                    } else if (fruit2.isBomb) {
                        explodeBomb(row1, col1, 2);
                        grid[row1][col1].startExplosion();
                        grid[row2][col2].startExplosion();
                        setTimeout(() => {
                            grid[row1][col1] = null;
                            grid[row2][col2] = null;
                            dropFruits();
                            isAnimating = false;
                        }, EXPLOSION_ANIMATION_DURATION);
                        score += 30;
                    } else if (fruit2.isWatermelon) {
                        const bombType = fruit1.type;
                        for (let r = 0; r < GRID_SIZE_ROWS; r++) {
                            for (let c = 0; c < GRID_SIZE_COLS; c++) {
                                if (grid[r][c] && grid[r][c].type === bombType && !grid[r][c].isBomb && !grid[r][c].isWatermelon && !grid[r][c].isBee) {
                                    grid[r][c] = new Fruit(r, c, bombType, true);
                                    grid[r][c].startExplosion();
                                }
                            }
                        }
                        grid[row1][col1].startExplosion();
                        grid[row2][col2].startExplosion();
                        setTimeout(() => {
                            for (let r = 0; r < GRID_SIZE_ROWS; r++) {
                                for (let c = 0; c < GRID_SIZE_COLS; c++) {
                                    if (grid[r][c] && grid[r][c].isMarked) grid[r][c] = null;
                                }
                            }
                            dropFruits();
                            isAnimating = false;
                        }, EXPLOSION_ANIMATION_DURATION);
                        score += 40;
                    } else {
                        grid[row1][col1] = fruit1;
                        grid[row2][col2] = fruit2;
                        fruit1.startAnimation(row1, col1);
                        fruit2.startAnimation(row2, col2);
                        setTimeout(() => isAnimating = false, ANIMATION_DURATION);
                    }
                } else if (fruit2.isBomb) {
                    const bombMatches = findBombMatches(row1, col1);
                    if (bombMatches.length > 0 && bombMatches.some(match => match.length >= 2)) {
                        explodeBomb(row1, col1, 1);
                        grid[row1][col1].startExplosion();
                        bombMatches.forEach(match => match.forEach(([r, c]) => grid[r][c].startExplosion()));
                        setTimeout(() => {
                            grid[row1][col1] = null;
                            bombMatches.forEach(match => match.forEach(([r, c]) => grid[r][c] = null));
                            dropFruits();
                            isAnimating = false;
                        }, EXPLOSION_ANIMATION_DURATION);
                        score += 15;
                    } else if (fruit1.isWatermelon) {
                        const bombType = fruit2.type;
                        for (let r = 0; r < GRID_SIZE_ROWS; r++) {
                            for (let c = 0; c < GRID_SIZE_COLS; c++) {
                                if (grid[r][c] && grid[r][c].type === bombType && !grid[r][c].isBomb && !grid[r][c].isWatermelon && !grid[r][c].isBee) {
                                    grid[r][c] = new Fruit(r, c, bombType, true);
                                    grid[r][c].startExplosion();
                                }
                            }
                        }
                        grid[row1][col1].startExplosion();
                        grid[row2][col2].startExplosion();
                        setTimeout(() => {
                            for (let r = 0; r < GRID_SIZE_ROWS; r++) {
                                for (let c = 0; c < GRID_SIZE_COLS; c++) {
                                    if (grid[r][c] && grid[r][c].isMarked) grid[r][c] = null;
                                }
                            }
                            dropFruits();
                            isAnimating = false;
                        }, EXPLOSION_ANIMATION_DURATION);
                        score += 40;
                    } else {
                        grid[row1][col1] = fruit1;
                        grid[row2][col2] = fruit2;
                        fruit1.startAnimation(row1, col1);
                        fruit2.startAnimation(row2, col2);
                        setTimeout(() => isAnimating = false, ANIMATION_DURATION);
                    }
                } else if (fruit1.isWatermelon) {
                    const typeToRemove = fruit2.type;
                    for (let r = 0; r < GRID_SIZE_ROWS; r++) {
                        for (let c = 0; c < GRID_SIZE_COLS; c++) {
                            if (grid[r][c] && grid[r][c].type === typeToRemove) {
                                grid[r][c].isMarked = true;
                                grid[r][c].startFade();
                            }
                        }
                    }
                    setTimeout(() => {
                        for (let r = 0; r < GRID_SIZE_ROWS; r++) {
                            for (let c = 0; c < GRID_SIZE_COLS; c++) {
                                if (grid[r][c] && grid[r][c].isMarked) grid[r][c] = null;
                            }
                        }
                        dropFruits();
                        isAnimating = false;
                    }, ANIMATION_DURATION);
                    score += 50;
                } else if (fruit2.isWatermelon) {
                    const typeToRemove = fruit1.type;
                    for (let r = 0; r < GRID_SIZE_ROWS; r++) {
                        for (let c = 0; c < GRID_SIZE_COLS; c++) {
                            if (grid[r][c] && grid[r][c].type === typeToRemove) {
                                grid[r][c].isMarked = true;
                                grid[r][c].startFade();
                            }
                        }
                    }
                    setTimeout(() => {
                        for (let r = 0; r < GRID_SIZE_ROWS; r++) {
                            for (let c = 0; c < GRID_SIZE_COLS; c++) {
                                if (grid[r][c] && grid[r][c].isMarked) grid[r][c] = null;
                            }
                        }
                        dropFruits();
                        isAnimating = false;
                    }, ANIMATION_DURATION);
                    score += 50;
                } else if (fruit1.isBee) {
                    explodeBee(row2, col2);
                    grid[row2][col2].startExplosion();
                    setTimeout(() => {
                        grid[row2][col2] = null;
                        dropFruits();
                        isAnimating = false;
                    }, EXPLOSION_ANIMATION_DURATION);
                    score += 10;
                } else if (fruit2.isBee) {
                    explodeBee(row1, col1);
                    grid[row1][col1].startExplosion();
                    setTimeout(() => {
                        grid[row1][col1] = null;
                        dropFruits();
                        isAnimating = false;
                    }, EXPLOSION_ANIMATION_DURATION);
                    score += 10;
                } else {
                    grid[row1][col1] = fruit1;
                    grid[row2][col2] = fruit2;
                    fruit1.startAnimation(row1, col1);
                    fruit2.startAnimation(row2, col2);
                    setTimeout(() => isAnimating = false, ANIMATION_DURATION);
                }
                scoreDisplay.textContent = `Puntaje: ${score} / ${SCORE_GOAL}`;
            }, ANIMATION_DURATION);
        }

        function endGame(won) {
            gameOver = true;
            gameOverDisplay.style.display = 'block';
            if (won) {
                gameResultDisplay.textContent = '¬°Ganaste!';
                finalScoreDisplay.textContent = score;
            } else {
                gameResultDisplay.textContent = 'Perdiste';
                finalScoreDisplay.textContent = score;
            }
        }

        function startGame() {
            gameStarted = true;
            startScreen.style.display = 'none';
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#333';
            for (let row = 0; row <= GRID_SIZE_ROWS; row++) {
                ctx.beginPath();
                ctx.moveTo(0, row * CELL_SIZE);
                ctx.lineTo(canvas.width, row * CELL_SIZE);
                ctx.stroke();
            }
            for (let col = 0; col <= GRID_SIZE_COLS; col++) {
                ctx.beginPath();
                ctx.moveTo(col * CELL_SIZE, 0);
                ctx.lineTo(col * CELL_SIZE, canvas.height);
                ctx.stroke();
            }

            if (grid.length > 0) {
                for (let row = 0; row < GRID_SIZE_ROWS; row++) {
                    for (let col = 0; col < GRID_SIZE_COLS; col++) {
                        if (grid[row][col]) {
                            grid[row][col].update();
                            grid[row][col].draw();
                        }
                    }
                }
            }

            bees.forEach(bee => {
                ctx.save();
                ctx.translate(bee.x, bee.y);
                ctx.fillStyle = '#FFFF00';
                ctx.font = `${CELL_SIZE / 2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üêù', 0, 0);
                ctx.restore();
            });

            if (selectedFruit && !isAnimating) {
                const x = selectedFruit.col * CELL_SIZE;
                const y = selectedFruit.row * CELL_SIZE;
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, CELL_SIZE, CELL_SIZE);
            }

            requestAnimationFrame(gameLoop);
        }

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (!gameOver && gameStarted && !isAnimating) {
                const x = e.clientX - canvas.offsetLeft;
                const y = e.clientY - canvas.offsetTop;
                const col = Math.floor(x / CELL_SIZE);
                const row = Math.floor(y / CELL_SIZE);
                if (row >= 0 && row < GRID_SIZE_ROWS && col >= 0 && col < GRID_SIZE_COLS && grid[row][col]) {
                    selectedFruit = { row, col };
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            e.preventDefault();
            if (!gameOver && gameStarted && selectedFruit && !isAnimating) {
                const x = e.clientX - canvas.offsetLeft;
                const y = e.clientY - canvas.offsetTop;
                const col = Math.floor(x / CELL_SIZE);
                const row = Math.floor(y / CELL_SIZE);
                if (row >= 0 && row < GRID_SIZE_ROWS && col >= 0 && col < GRID_SIZE_COLS && grid[row][col] &&
                    (row !== selectedFruit.row || col !== selectedFruit.col)) {
                    swapFruits(selectedFruit.row, selectedFruit.col, row, col);
                    selectedFruit = null;
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            selectedFruit = null;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameOver && gameStarted && !isAnimating) {
                const touchX = e.touches[0].clientX - canvas.offsetLeft;
                const touchY = e.touches[0].clientY - canvas.offsetTop;
                const col = Math.floor(touchX / CELL_SIZE);
                const row = Math.floor(touchY / CELL_SIZE);
                if (row >= 0 && row < GRID_SIZE_ROWS && col >= 0 && col < GRID_SIZE_COLS && grid[row][col]) {
                    selectedFruit = { row, col };
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!gameOver && gameStarted && selectedFruit && !isAnimating) {
                const touchX = e.touches[0].clientX - canvas.offsetLeft;
                const touchY = e.touches[0].clientY - canvas.offsetTop;
                const col = Math.floor(touchX / CELL_SIZE);
                const row = Math.floor(touchY / CELL_SIZE);
                if (row >= 0 && row < GRID_SIZE_ROWS && col >= 0 && col < GRID_SIZE_COLS && grid[row][col] &&
                    (row !== selectedFruit.row || col !== selectedFruit.col)) {
                    swapFruits(selectedFruit.row, selectedFruit.col, row, col);
                    selectedFruit = null;
                }
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            selectedFruit = null;
        });

        startButton.addEventListener('click', startGame);

        initializeGrid();
        gameLoop();
    </script>
</body>
</html>